<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTPoly: sparsematrixalgebramodule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NTPoly
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">sparsematrixalgebramodule Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A module for performing linear algebra using sparse matrices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a8d2ebf0840fd68ad47fe7b8f9000899a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a8d2ebf0840fd68ad47fe7b8f9000899a">scalesparsematrix</a> (matA, constant)</td></tr>
<tr class="memdesc:a8d2ebf0840fd68ad47fe7b8f9000899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will scale a sparse matrix by a constant.  <a href="#a8d2ebf0840fd68ad47fe7b8f9000899a">More...</a><br /></td></tr>
<tr class="separator:a8d2ebf0840fd68ad47fe7b8f9000899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ea470899228f9b2c1487a0c86eb64e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a75ea470899228f9b2c1487a0c86eb64e">incrementsparsematrix</a> (matA, matB, alpha_in, threshold_in)</td></tr>
<tr class="memdesc:a75ea470899228f9b2c1487a0c86eb64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix B = alpha*Matrix A + Matrix B (AXPY). This will utilize the sparse vector addition routine.  <a href="#a75ea470899228f9b2c1487a0c86eb64e">More...</a><br /></td></tr>
<tr class="separator:a75ea470899228f9b2c1487a0c86eb64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8130981b4814c5f90708d667e4e995d2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a8130981b4814c5f90708d667e4e995d2">pairwisemultiplysparsematrix</a> (matA, matB, matC)</td></tr>
<tr class="memdesc:a8130981b4814c5f90708d667e4e995d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pairwise Multiply two matrices. This will utilize the sparse vector pairwise routine.  <a href="#a8130981b4814c5f90708d667e4e995d2">More...</a><br /></td></tr>
<tr class="separator:a8130981b4814c5f90708d667e4e995d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b57cb68927787bc27cde10c889964"><td class="memItemLeft" align="right" valign="top">pure real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a693b57cb68927787bc27cde10c889964">dotsparsematrix</a> (matA, matB)</td></tr>
<tr class="memdesc:a693b57cb68927787bc27cde10c889964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product = sum(MatA[ij]*MatB[ij])  <a href="#a693b57cb68927787bc27cde10c889964">More...</a><br /></td></tr>
<tr class="separator:a693b57cb68927787bc27cde10c889964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347924cc21787b95dcfd5aca64bd244f"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a347924cc21787b95dcfd5aca64bd244f">gemm</a> (matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in)</td></tr>
<tr class="memdesc:a347924cc21787b95dcfd5aca64bd244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices together, and add to the third. C := alpha*matA*op( matB ) + beta*matC This version is not really linear scaling, but it should be fast enough. Basically, we create a big buffer region of zeros so that we can accumulate in O(1) time. Then we scan over the buffer region and search for filled values. For small enough matrices this is fine, but it definitely isn't optimal.  <a href="#a347924cc21787b95dcfd5aca64bd244f">More...</a><br /></td></tr>
<tr class="separator:a347924cc21787b95dcfd5aca64bd244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16e9a6cf8cf4048103a4679d504bad"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a0e16e9a6cf8cf4048103a4679d504bad">sparsematrixnorm</a> (this, norm_per_column)</td></tr>
<tr class="memdesc:a0e16e9a6cf8cf4048103a4679d504bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a sparse matrix along the columns.  <a href="#a0e16e9a6cf8cf4048103a4679d504bad">More...</a><br /></td></tr>
<tr class="separator:a0e16e9a6cf8cf4048103a4679d504bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b654d27c6c937f62764fda69464f155"><td class="memItemLeft" align="right" valign="top">pure real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixalgebramodule.html#a9b654d27c6c937f62764fda69464f155">sparsematrixgrandsum</a> (this)</td></tr>
<tr class="memdesc:a9b654d27c6c937f62764fda69464f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the elements of a matrix.  <a href="#a9b654d27c6c937f62764fda69464f155">More...</a><br /></td></tr>
<tr class="separator:a9b654d27c6c937f62764fda69464f155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A module for performing linear algebra using sparse matrices. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a693b57cb68927787bc27cde10c889964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b57cb68927787bc27cde10c889964">&#9670;&nbsp;</a></span>dotsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure real(ntreal) function, public sparsematrixalgebramodule::dotsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Product = sum(MatA[ij]*MatB[ij]) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product </dd></dl>

</div>
</div>
<a id="a347924cc21787b95dcfd5aca64bd244f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347924cc21787b95dcfd5aca64bd244f">&#9670;&nbsp;</a></span>gemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sparsematrixalgebramodule::gemm </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(inout)&#160;</td>
          <td class="paramname"><em>matC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>IsATransposed_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>IsBTransposed_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>beta_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(matrixmemorypool_t), intent(inout), optional, target&#160;</td>
          <td class="paramname"><em>blocked_memory_pool_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two matrices together, and add to the third. C := alpha*matA*op( matB ) + beta*matC This version is not really linear scaling, but it should be fast enough. Basically, we create a big buffer region of zeros so that we can accumulate in O(1) time. Then we scan over the buffer region and search for filled values. For small enough matrices this is fine, but it definitely isn't optimal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matC</td><td>= alpha*matA*op( matB ) + beta*matC. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsATransposed_in</td><td>true if A is already transposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IsBTransposed_in</td><td>true if B is already transposed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>scales the multiplication. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta_in</td><td>scales matrix we sum on to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">blocked_memory_pool_in</td><td>an optional memory pool for doing the calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75ea470899228f9b2c1487a0c86eb64e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ea470899228f9b2c1487a0c86eb64e">&#9670;&nbsp;</a></span>incrementsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixalgebramodule::incrementsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix B = alpha*Matrix A + Matrix B (AXPY). This will utilize the sparse vector addition routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>multiplier. Optional, default is 1.0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>I don't like this hack where I have to check if MatrixB is allocated. </dd></dl>

</div>
</div>
<a id="a8130981b4814c5f90708d667e4e995d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8130981b4814c5f90708d667e4e995d2">&#9670;&nbsp;</a></span>pairwisemultiplysparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixalgebramodule::pairwisemultiplysparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(sparsematrix_t), intent(inout)&#160;</td>
          <td class="paramname"><em>matC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pairwise Multiply two matrices. This will utilize the sparse vector pairwise routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matC</td><td>= MatA mult MatB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d2ebf0840fd68ad47fe7b8f9000899a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2ebf0840fd68ad47fe7b8f9000899a">&#9670;&nbsp;</a></span>scalesparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixalgebramodule::scalesparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(inout)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in)&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will scale a sparse matrix by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b654d27c6c937f62764fda69464f155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b654d27c6c937f62764fda69464f155">&#9670;&nbsp;</a></span>sparsematrixgrandsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure real(ntreal) function, public sparsematrixalgebramodule::sparsematrixgrandsum </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum the elements of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum_value the sum of the matrix elements </dd></dl>

</div>
</div>
<a id="a0e16e9a6cf8cf4048103a4679d504bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16e9a6cf8cf4048103a4679d504bad">&#9670;&nbsp;</a></span>sparsematrixnorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixalgebramodule::sparsematrixnorm </td>
          <td>(</td>
          <td class="paramtype">type(sparsematrix_t), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), dimension(:), intent(out), allocatable&#160;</td>
          <td class="paramname"><em>norm_per_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a sparse matrix along the columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the norm of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">norm_per_column</td><td>the norm value for each column in this matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
