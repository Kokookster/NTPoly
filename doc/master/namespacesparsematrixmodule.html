<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTPoly: sparsematrixmodule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NTPoly
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">sparsematrixmodule Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A module for handling locally stored CSR matrices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A datatype for storing a CSR matrix.  <a href="structsparsematrixmodule_1_1sparsematrix__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a48fffe3459b3cbc7c769d9bdf854a87a"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a48fffe3459b3cbc7c769d9bdf854a87a">constructemptysparsematrix</a> (this, columns, rows)</td></tr>
<tr class="memdesc:a48fffe3459b3cbc7c769d9bdf854a87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse matrix with a certain number of columns and rows. Will allocate storage for the outer values.  <a href="#a48fffe3459b3cbc7c769d9bdf854a87a">More...</a><br /></td></tr>
<tr class="separator:a48fffe3459b3cbc7c769d9bdf854a87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea43b1155f5d2f9a60b266898b7208e8"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#aea43b1155f5d2f9a60b266898b7208e8">constructsparsematrixfromfile</a> (this, file_name)</td></tr>
<tr class="memdesc:aea43b1155f5d2f9a60b266898b7208e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse matrix by reading in a matrix market file.  <a href="#aea43b1155f5d2f9a60b266898b7208e8">More...</a><br /></td></tr>
<tr class="separator:aea43b1155f5d2f9a60b266898b7208e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b3ae65c813eba65e4e93d839eb8e88"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a32b3ae65c813eba65e4e93d839eb8e88">constructfromtripletlist</a> (this, triplet_list, rows, columns)</td></tr>
<tr class="memdesc:a32b3ae65c813eba65e4e93d839eb8e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix from a <b>SORTED</b> triplet list. The triplet list must be sorted to efficiently fill in the matrix. This constructor assumes <b>you</b> have already sorted the triplet list.  <a href="#a32b3ae65c813eba65e4e93d839eb8e88">More...</a><br /></td></tr>
<tr class="separator:a32b3ae65c813eba65e4e93d839eb8e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfb7d3909100046866c5a0ce81bac84"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a5cfb7d3909100046866c5a0ce81bac84">destructsparsematrix</a> (this)</td></tr>
<tr class="memdesc:a5cfb7d3909100046866c5a0ce81bac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly destruct a sparse matrix. This will always check if arrays are actually allocated, so you can feel free to destruct a matrix even if it has no data.  <a href="#a5cfb7d3909100046866c5a0ce81bac84">More...</a><br /></td></tr>
<tr class="separator:a5cfb7d3909100046866c5a0ce81bac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997657c01bb95d81d4656ab4be711dc6"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a997657c01bb95d81d4656ab4be711dc6">copysparsematrix</a> (matA, matB)</td></tr>
<tr class="memdesc:a997657c01bb95d81d4656ab4be711dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a sparse matrix in a safe way.  <a href="#a997657c01bb95d81d4656ab4be711dc6">More...</a><br /></td></tr>
<tr class="separator:a997657c01bb95d81d4656ab4be711dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95145de3991c6b39f30abbb62f1f726"><td class="memItemLeft" align="right" valign="top">pure integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#ac95145de3991c6b39f30abbb62f1f726">getrows</a> (this)</td></tr>
<tr class="memdesc:ac95145de3991c6b39f30abbb62f1f726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of rows of a matrix.  <a href="#ac95145de3991c6b39f30abbb62f1f726">More...</a><br /></td></tr>
<tr class="separator:ac95145de3991c6b39f30abbb62f1f726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42409a427e0ba40ea1e2c59b4c5d9669"><td class="memItemLeft" align="right" valign="top">pure integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a42409a427e0ba40ea1e2c59b4c5d9669">getcolumns</a> (this)</td></tr>
<tr class="memdesc:a42409a427e0ba40ea1e2c59b4c5d9669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of columns of a matrix.  <a href="#a42409a427e0ba40ea1e2c59b4c5d9669">More...</a><br /></td></tr>
<tr class="separator:a42409a427e0ba40ea1e2c59b4c5d9669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22099ebd7c19ede253a13f671cec0c5d"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a22099ebd7c19ede253a13f671cec0c5d">transposesparsematrix</a> (this, matT)</td></tr>
<tr class="memdesc:a22099ebd7c19ede253a13f671cec0c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a sparse matrix and return it in a separate matrix. The current implementation has you go from matrix to triplet list, triplet list to transposed triplet list. The triplet list must then be sorted and then the return matrix is constructed.  <a href="#a22099ebd7c19ede253a13f671cec0c5d">More...</a><br /></td></tr>
<tr class="separator:a22099ebd7c19ede253a13f671cec0c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8610d41ff5ab8f855f8d21667f0048c3"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a8610d41ff5ab8f855f8d21667f0048c3">composesparsematrixcolumns</a> (mat_list, out_matrix)</td></tr>
<tr class="memdesc:a8610d41ff5ab8f855f8d21667f0048c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of the first matrix are followed by the columns of the matrices in the list.  <a href="#a8610d41ff5ab8f855f8d21667f0048c3">More...</a><br /></td></tr>
<tr class="separator:a8610d41ff5ab8f855f8d21667f0048c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61f53ced7964009373539135ffd004e"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#ae61f53ced7964009373539135ffd004e">splitsparsematrixcolumns</a> (this, num_blocks, split_list, block_offsets_out)</td></tr>
<tr class="memdesc:ae61f53ced7964009373539135ffd004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a matrix, and split into into small blocks.  <a href="#ae61f53ced7964009373539135ffd004e">More...</a><br /></td></tr>
<tr class="separator:ae61f53ced7964009373539135ffd004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9982e6e020366bdba866eb814b943ae4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a9982e6e020366bdba866eb814b943ae4">matrixtotripletlist</a> (this, triplet_list)</td></tr>
<tr class="memdesc:a9982e6e020366bdba866eb814b943ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a triplet list from a matrix.  <a href="#a9982e6e020366bdba866eb814b943ae4">More...</a><br /></td></tr>
<tr class="separator:a9982e6e020366bdba866eb814b943ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8e78f04a9343b732748a7e9719a8fb"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a4d8e78f04a9343b732748a7e9719a8fb">printsparsematrix</a> (this, file_name_in)</td></tr>
<tr class="memdesc:a4d8e78f04a9343b732748a7e9719a8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a sparse matrix. We first create a triplet list, and then call the print triplet list function.  <a href="#a4d8e78f04a9343b732748a7e9719a8fb">More...</a><br /></td></tr>
<tr class="separator:a4d8e78f04a9343b732748a7e9719a8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4045dfc6797ed4efc54b42e0323ca398"><td class="memItemLeft" align="right" valign="top">pure logical function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesparsematrixmodule.html#a4045dfc6797ed4efc54b42e0323ca398">checkifidentity</a> (this, threshold_in)</td></tr>
<tr class="memdesc:a4045dfc6797ed4efc54b42e0323ca398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a matrix is equal to the identity matrix. This routine is really just for testing. You can multiply a matrix and its inverse, and then call this routine to make sure multiplication is correct.  <a href="#a4045dfc6797ed4efc54b42e0323ca398">More...</a><br /></td></tr>
<tr class="separator:a4045dfc6797ed4efc54b42e0323ca398"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A module for handling locally stored CSR matrices. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a4045dfc6797ed4efc54b42e0323ca398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4045dfc6797ed4efc54b42e0323ca398">&#9670;&nbsp;</a></span>checkifidentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure logical function, public sparsematrixmodule::checkifidentity </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a matrix is equal to the identity matrix. This routine is really just for testing. You can multiply a matrix and its inverse, and then call this routine to make sure multiplication is correct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 10^-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the matrix is equal to the identity matrix. </dd></dl>

</div>
</div>
<a id="a8610d41ff5ab8f855f8d21667f0048c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8610d41ff5ab8f855f8d21667f0048c3">&#9670;&nbsp;</a></span>composesparsematrixcolumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::composesparsematrixcolumns </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>mat_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>out_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of the first matrix are followed by the columns of the matrices in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat_list</td><td>list of matrices to compose. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_matrix</td><td>= [Matrix 1 | Matrix 2, ...] . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48fffe3459b3cbc7c769d9bdf854a87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fffe3459b3cbc7c769d9bdf854a87a">&#9670;&nbsp;</a></span>constructemptysparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::constructemptysparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparse matrix with a certain number of columns and rows. Will allocate storage for the outer values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the matrix being created. It will have the outer index allocated, but nothing else. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>number of matrix columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b3ae65c813eba65e4e93d839eb8e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b3ae65c813eba65e4e93d839eb8e88">&#9670;&nbsp;</a></span>constructfromtripletlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::constructfromtripletlist </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(tripletlist_t), intent(in)&#160;</td>
          <td class="paramname"><em>triplet_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix from a <b>SORTED</b> triplet list. The triplet list must be sorted to efficiently fill in the matrix. This constructor assumes <b>you</b> have already sorted the triplet list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the matrix being constructed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triplet_list</td><td>a list of triplet values. They must be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of matrix rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>number of matrix columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea43b1155f5d2f9a60b266898b7208e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea43b1155f5d2f9a60b266898b7208e8">&#9670;&nbsp;</a></span>constructsparsematrixfromfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sparsematrixmodule::constructsparsematrixfromfile </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sparse matrix by reading in a matrix market file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the matrix being constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a997657c01bb95d81d4656ab4be711dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997657c01bb95d81d4656ab4be711dc6">&#9670;&nbsp;</a></span>copysparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::copysparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a sparse matrix in a safe way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>matrix to copy </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>= matA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cfb7d3909100046866c5a0ce81bac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfb7d3909100046866c5a0ce81bac84">&#9670;&nbsp;</a></span>destructsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::destructsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly destruct a sparse matrix. This will always check if arrays are actually allocated, so you can feel free to destruct a matrix even if it has no data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix to free up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42409a427e0ba40ea1e2c59b4c5d9669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42409a427e0ba40ea1e2c59b4c5d9669">&#9670;&nbsp;</a></span>getcolumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function, public sparsematrixmodule::getcolumns </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of columns of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of columns. </dd></dl>

</div>
</div>
<a id="ac95145de3991c6b39f30abbb62f1f726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95145de3991c6b39f30abbb62f1f726">&#9670;&nbsp;</a></span>getrows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function, public sparsematrixmodule::getrows </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of rows of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of rows. </dd></dl>

</div>
</div>
<a id="a9982e6e020366bdba866eb814b943ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9982e6e020366bdba866eb814b943ae4">&#9670;&nbsp;</a></span>matrixtotripletlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::matrixtotripletlist </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(tripletlist_t), intent(inout)&#160;</td>
          <td class="paramname"><em>triplet_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a triplet list from a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to construct the triplet list from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triplet_list</td><td>the triplet list we created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d8e78f04a9343b732748a7e9719a8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8e78f04a9343b732748a7e9719a8fb">&#9670;&nbsp;</a></span>printsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public sparsematrixmodule::printsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>file_name_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a sparse matrix. We first create a triplet list, and then call the print triplet list function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name_in</td><td>optionally, you can pass a file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae61f53ced7964009373539135ffd004e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61f53ced7964009373539135ffd004e">&#9670;&nbsp;</a></span>splitsparsematrixcolumns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::splitsparsematrixcolumns </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), dimension(num_blocks), intent(out)&#160;</td>
          <td class="paramname"><em>split_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(num_blocks+1), intent(out), optional&#160;</td>
          <td class="paramname"><em>block_offsets_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a matrix, and split into into small blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>matrix to perform this operation on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_blocks</td><td>number of blocks to split into. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">split_list</td><td>1D array of blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block_offsets_out</td><td>the offsets used for splitting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22099ebd7c19ede253a13f671cec0c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22099ebd7c19ede253a13f671cec0c5d">&#9670;&nbsp;</a></span>transposesparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public sparsematrixmodule::transposesparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structsparsematrixmodule_1_1sparsematrix__t.html">sparsematrix_t</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose a sparse matrix and return it in a separate matrix. The current implementation has you go from matrix to triplet list, triplet list to transposed triplet list. The triplet list must then be sorted and then the return matrix is constructed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to be transposed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matT</td><td>the input matrix transposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
