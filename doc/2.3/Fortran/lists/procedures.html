<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
    <meta name="description" content="Documentation for NTPoly">
   
    <meta name="author" content="" >
    <link rel="icon" href="../favicon.png">

    <title>
All Procedures &ndash; NTPoly
</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    
    <link href="../css/user.css" rel="stylesheet">
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">NTPoly </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
        
            </ul>
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>


          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			 
			   <tr><td><a href='../interface/accumulatetripletlist.html'>AccumulateTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/accumulatetripletlist_c.html'>AccumulateTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>(Just for a related project)</p></td></tr>
			 
			   <tr><td><a href='../proc/accumulatetripletlist_r.html'>AccumulateTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>(Just for a related project)</p></td></tr>
			 
			   <tr><td><a href='../proc/activatelogger.html'>ActivateLogger</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Activate the logger.</p></td></tr>
			 
			   <tr><td><a href='../interface/addsparsevectors.html'>AddSparseVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/appendtotripletlist.html'>AppendToTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/appendtotripletlist_c.html'>AppendToTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Add a value to the end of the triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/appendtotripletlist_r.html'>AppendToTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Add a value to the end of the triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/cgsolver.html'>CGSolver</a></td><td><a href='../module/linearsolversmodule.html'>LinearSolversModule</a></td><td>Subroutine</td><td><p>Solve the matrix equation AX = B using the conjugate gradient method.</p></td></tr>
			 
			   <tr><td><a href='../proc/checkallocerror.html'>CheckAllocError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Routine to call if an alloc error has occurred.</p></td></tr>
			 
			   <tr><td><a href='../interface/checkmemorypoolvalidity.html'>CheckMemoryPoolValidity</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/checkmemorypoolvalidity~2.html'>CheckMemoryPoolValidity</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/checkmpierror.html'>CheckMPIError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Routine to call to check if an MPI error has occurred.</p></td></tr>
			 
			   <tr><td><a href='../proc/cleanup.html'>Cleanup</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>As a last case resort, this will print an error message and quit.</p></td></tr>
			 
			   <tr><td><a href='../interface/commsplitmatrix.html'>CommSplitMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/comparetriplets.html'>CompareTriplets</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/composematrix.html'>ComposeMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/composematrix~2.html'>ComposeMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/composematrixcolumns.html'>ComposeMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/compute.html'>Compute</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/compute~2.html'>Compute</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/compute~3.html'>Compute</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/computeexponential.html'>ComputeExponential</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/computeexponentialpade.html'>ComputeExponentialPade</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix using a pade approximation.
 Be warned, the pade method can result in a lot of intermediate fill.</p></td></tr>
			 
			   <tr><td><a href='../proc/computeexponentialtaylor.html'>ComputeExponentialTaylor</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix using a taylor series expansion.
 This is only really useful if you have a very small spectrum, because
 quite a bit of scaling is required.</p></td></tr>
			 
			   <tr><td><a href='../proc/computeinverseroot.html'>ComputeInverseRoot</a></td><td><a href='../module/rootsolversmodule.html'>RootSolversModule</a></td><td>Subroutine</td><td><p>Compute a general inverse matrix root.</p></td></tr>
			 
			   <tr><td><a href='../proc/computelogarithm.html'>ComputeLogarithm</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the logarithm of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/computelogarithmtaylor.html'>ComputeLogarithmTaylor</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the logarithm of a matrix using a taylor series expansion.</p></td></tr>
			 
			   <tr><td><a href='../proc/computeroot.html'>ComputeRoot</a></td><td><a href='../module/rootsolversmodule.html'>RootSolversModule</a></td><td>Subroutine</td><td><p>Compute a general matrix root.</p></td></tr>
			 
			   <tr><td><a href='../interface/conjugatematrix.html'>ConjugateMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/conjugatematrix~2.html'>ConjugateMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/constructdefaultpermutation.html'>ConstructDefaultPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that preserves the original order.</p></td></tr>
			 
			   <tr><td><a href='../interface/constructemptymatrix.html'>ConstructEmptyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructemptymatrix~2.html'>ConstructEmptyMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructemptymatrix~3.html'>ConstructEmptyMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/constructerror.html'>ConstructError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Default constructor for an error type.</p></td></tr>
			 
			   <tr><td><a href='../proc/constructlimitedrandompermutation.html'>ConstructLimitedRandomPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that has a random order, but there is no
 permutation from beyond the actual matrix dimension.</p></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixdfroms.html'>ConstructMatrixDFromS</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixfrombinary.html'>ConstructMatrixFromBinary</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixfromfile.html'>ConstructMatrixFromFile</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixfrommatrixmarket.html'>ConstructMatrixFromMatrixMarket</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixfromtripletlist.html'>ConstructMatrixFromTripletList</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixmemorypool.html'>ConstructMatrixMemoryPool</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructmatrixsfromd.html'>ConstructMatrixSFromD</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructnewprocessgrid.html'>ConstructNewProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructpolynomial.html'>ConstructPolynomial</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructpolynomial~2.html'>ConstructPolynomial</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructpolynomial~3.html'>ConstructPolynomial</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/constructprocessgrid.html'>ConstructProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/constructrandompermutation.html'>ConstructRandomPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that has a random order.
 Implements Knuth shuffle.</p></td></tr>
			 
			   <tr><td><a href='../proc/constructreversepermutation.html'>ConstructReversePermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that reverses the original order.</p></td></tr>
			 
			   <tr><td><a href='../interface/constructtripletlist.html'>ConstructTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/constructtripletlist_c.html'>ConstructTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Function</td><td><p>Construct a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/constructtripletlist_r.html'>ConstructTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Function</td><td><p>Construct a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/constructtripletlistsup_c.html'>ConstructTripletListSup_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Subroutine wrapper for constructing a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/constructtripletlistsup_r.html'>ConstructTripletListSup_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Subroutine wrapper for constructing a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/convertmatrixtocomplex.html'>ConvertMatrixToComplex</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Converts the current matrix to a complex type matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/convertmatrixtoreal.html'>ConvertMatrixToReal</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Converts the current matrix to a real type matrix.</p></td></tr>
			 
			   <tr><td><a href='../interface/convertmatrixtype.html'>ConvertMatrixType</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/converttripletlisttocomplex.html'>ConvertTripletListToComplex</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Convert a real triplet to a complex triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/converttripletlisttoreal.html'>ConvertTripletListToReal</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Convert a complex triplet list to a real triplet list.</p></td></tr>
			 
			   <tr><td><a href='../interface/converttripletlisttype.html'>ConvertTripletListType</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/converttriplettype.html'>ConvertTripletType</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/copymatrix.html'>CopyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/copymatrix~2.html'>CopyMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/copymatrix~3.html'>CopyMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/copyprocessgrid.html'>CopyProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Copy a process grid.
 Note that this makes a complete and independent copy of the process grid.
 Which of course means that whatever is currently stored in new_grid will
 be destroyed, so do not leave any matrices pointing to it.</p></td></tr>
			 
			   <tr><td><a href='../proc/cosine.html'>Cosine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the cosine of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/deactivatelogger.html'>DeactivateLogger</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Deactivate the logger.</p></td></tr>
			 
			   <tr><td><a href='../interface/destructmatrix.html'>DestructMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructmatrix~2.html'>DestructMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructmatrix~3.html'>DestructMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructmatrixmemorypool.html'>DestructMatrixMemoryPool</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructmatrixmemorypool~2.html'>DestructMatrixMemoryPool</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/destructpermutation.html'>DestructPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Destruct a permutation object.</p></td></tr>
			 
			   <tr><td><a href='../interface/destructpolynomial.html'>DestructPolynomial</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructpolynomial~2.html'>DestructPolynomial</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/destructpolynomial~3.html'>DestructPolynomial</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/destructprocessgrid.html'>DestructProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Destruct a process grid.
 Be careful about doing this. Matrices have pointers to process grids. If
 you destruct a process grid without destructing the matrices pointing to
 it, they will become unusable.</p></td></tr>
			 
			   <tr><td><a href='../proc/destructsolverparameters.html'>DestructSolverParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Cleanup the solver parameters datastructure.</p></td></tr>
			 
			   <tr><td><a href='../interface/destructtripletlist.html'>DestructTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/destructtripletlist_c.html'>DestructTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Destructs a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/destructtripletlist_r.html'>DestructTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Destructs a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../interface/dotmatrix.html'>DotMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/dotmatrix~2.html'>DotMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/dotsparsevectors.html'>DotSparseVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/energydensitymatrix.html'>EnergyDensityMatrix</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the energy-weighted density matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/entersublog.html'>EnterSubLog</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Call this subroutine when you enter into a section with verbose output</p></td></tr>
			 
			   <tr><td><a href='../proc/erroroccurred.html'>ErrorOccurred</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Check if an error has occurred or not.</p></td></tr>
			 
			   <tr><td><a href='../proc/exitsublog.html'>ExitSubLog</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Call this subroutine when you exit a section with verbose output</p></td></tr>
			 
			   <tr><td><a href='../interface/extractmatrixcolumn.html'>ExtractMatrixColumn</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/extractmatrixrow.html'>ExtractMatrixRow</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/factorizedcompute.html'>FactorizedCompute</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/factorizedcompute~2.html'>FactorizedCompute</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/fillmatrixfromtripletlist.html'>FillMatrixFromTripletList</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/fillmatrixidentity.html'>FillMatrixIdentity</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/fillmatrixpermutation.html'>FillMatrixPermutation</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/filtermatrix.html'>FilterMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/gathermatrixtoprocess.html'>GatherMatrixToProcess</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/gershgorinbounds.html'>GershgorinBounds</a></td><td><a href='../module/eigenboundsmodule.html'>EigenBoundsModule</a></td><td>Subroutine</td><td><p>Compute a bounds on the minimum and maximum eigenvalue of a matrix.
 Uses the Gershgorin theorem.</p></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixactualdimension.html'>GetMatrixActualDimension</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixblock.html'>GetMatrixBlock</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixcolumns.html'>GetMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixloadbalance.html'>GetMatrixLoadBalance</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixlogicaldimension.html'>GetMatrixLogicalDimension</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixrows.html'>GetMatrixRows</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixsize.html'>GetMatrixSize</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/getmatrixslice.html'>GetMatrixSlice</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Copy an arbitrary slice from a matrix into a new smaller matrix.
 NTPoly only works with square matrices, so if the number of rows and
 columns is different the matrix is resized to the maximum size.</p></td></tr>
			 
			   <tr><td><a href='../interface/getmatrixtripletlist.html'>GetMatrixTripletList</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/getmpitriplettype_c.html'>GetMPITripletType_c</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Function</td><td><p>Returns an MPI Derived Data Type For A Triplet.
 We statically store this derived type so that we do not have to recreate
 it every time this function is called. Thus this functional call should
 add very little overhead.</p></td></tr>
			 
			   <tr><td><a href='../proc/getmpitriplettype_r.html'>GetMPITripletType_r</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Function</td><td><p>Returns an MPI Derived Data Type For A Triplet.
 We statically store this derived type so that we do not have to recreate
 it every time this function is called. Thus this functional call should
 add very little overhead.</p></td></tr>
			 
			   <tr><td><a href='../proc/getmycolumn.html'>GetMyColumn</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the column of the current process.</p></td></tr>
			 
			   <tr><td><a href='../proc/getmyrow.html'>GetMyRow</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the row of the current process.</p></td></tr>
			 
			   <tr><td><a href='../proc/getmyslice.html'>GetMySlice</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the slice of the current process.</p></td></tr>
			 
			   <tr><td><a href='../interface/gettripletat.html'>GetTripletAt</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/gettripletat_c.html'>GetTripletAt_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Get the value of a triplet at a particular index.</p></td></tr>
			 
			   <tr><td><a href='../proc/gettripletat_r.html'>GetTripletAt_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Get the value of a triplet at a particular index.</p></td></tr>
			 
			   <tr><td><a href='../interface/gettripletlistsize.html'>GetTripletListSize</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/gettripletlistsize_c.html'>GetTripletListSize_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Function</td><td><p>Get the number of entries in a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/gettripletlistsize_r.html'>GetTripletListSize_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Function</td><td><p>Get the number of entries in a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../interface/gettripletvalues.html'>GetTripletValues</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/hpcp.html'>HPCP</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the HPCP method.
 Based on the algorithm presented in \cite truflandier2016communication.</p></td></tr>
			 
			   <tr><td><a href='../interface/incrementmatrix.html'>IncrementMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/incrementmatrix~2.html'>IncrementMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/incrementmatrix~3.html'>IncrementMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/inversesquareroot.html'>InverseSquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Compute the inverse square root of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/invert.html'>Invert</a></td><td><a href='../module/inversesolversmodule.html'>InverseSolversModule</a></td><td>Subroutine</td><td><p>Compute the inverse of a matrix.
 An implementation of the method of Hotelling \cite palser1998canonical.</p></td></tr>
			 
			   <tr><td><a href='../proc/isroot.html'>IsRoot</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Check if the current process is the root process.</p></td></tr>
			 
			   <tr><td><a href='../proc/lowdinextrapolate.html'>LowdinExtrapolate</a></td><td><a href='../module/geometryoptimizationmodule.html'>GeometryOptimizationModule</a></td><td>Subroutine</td><td><p>Create a new guess at the Density Matrix after updating the geometry.
 Based on the lowdin algorithm in \cite exner2002comparison .</p></td></tr>
			 
			   <tr><td><a href='../proc/mapmatrix_psc.html'>MapMatrix_psc</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Subroutine</td><td><p>Given a distributed matrix, apply this procedure to each element (complex).</p></td></tr>
			 
			   <tr><td><a href='../proc/mapmatrix_psr.html'>MapMatrix_psr</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Subroutine</td><td><p>Given a distributed matrix, apply this procedure to each element (real).</p></td></tr>
			 
			   <tr><td><a href='../interface/maptripletlist.html'>MapTripletList</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrix_ldc.html'>Matrix_ldc</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrix_ldr.html'>Matrix_ldr</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrix_lsc.html'>Matrix_lsc</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrix_lsr.html'>Matrix_lsr</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixcolumnnorm.html'>MatrixColumnNorm</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixgrandsum.html'>MatrixGrandSum</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixgrandsum~2.html'>MatrixGrandSum</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixmemorypool_lc.html'>MatrixMemoryPool_lc</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixmemorypool_lr.html'>MatrixMemoryPool_lr</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixmemorypool_p.html'>MatrixMemoryPool_p</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixmultiply.html'>MatrixMultiply</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixmultiply~2.html'>MatrixMultiply</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixnorm.html'>MatrixNorm</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixnorm~2.html'>MatrixNorm</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixnorm~3.html'>MatrixNorm</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixsigma.html'>MatrixSigma</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixtotripletlist.html'>MatrixToTripletList</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/matrixtrace.html'>MatrixTrace</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/mergematrixlocalblocks.html'>MergeMatrixLocalBlocks</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/multiplymatrix.html'>MultiplyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/pairwisemultiplymatrix.html'>PairwiseMultiplyMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/pairwisemultiplymatrix~2.html'>PairwiseMultiplyMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/pairwisemultiplyvectors.html'>PairwiseMultiplyVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/parsemmheader.html'>ParseMMHeader</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Function</td><td><p>Parse a matrix market header.</p></td></tr>
			 
			   <tr><td><a href='../proc/permutematrix.html'>PermuteMatrix</a></td><td><a href='../module/loadbalancermodule.html'>LoadBalancerModule</a></td><td>Subroutine</td><td><p>Apply a permutation to a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/pm.html'>PM</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the PM method.
 Based on the PM algorithm presented in \cite palser1998canonical</p></td></tr>
			 
			   <tr><td><a href='../proc/polardecomposition.html'>PolarDecomposition</a></td><td><a href='../module/signsolversmodule.html'>SignSolversModule</a></td><td>Subroutine</td><td><p>Computes the polar decomposition of a matrix Mat = U*H.</p></td></tr>
			 
			   <tr><td><a href='../proc/powerbounds.html'>PowerBounds</a></td><td><a href='../module/eigenboundsmodule.html'>EigenBoundsModule</a></td><td>Subroutine</td><td><p>Compute a bounds on the maximum eigenvalue of a matrix.
 Uses The Power Method.</p></td></tr>
			 
			   <tr><td><a href='../proc/printalltimers.html'>PrintAllTimers</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for each timer on this process.</p></td></tr>
			 
			   <tr><td><a href='../proc/printalltimersdistributed.html'>PrintAllTimersDistributed</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for each timer based on the max value across
 processes.</p></td></tr>
			 
			   <tr><td><a href='../proc/printerror.html'>PrintError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Print out that an error has occurred.</p></td></tr>
			 
			   <tr><td><a href='../interface/printmatrix.html'>PrintMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/printmatrix~2.html'>PrintMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/printmatrixinformation.html'>PrintMatrixInformation</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/printparameters.html'>PrintParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Print out the iterative solver parameter values.</p></td></tr>
			 
			   <tr><td><a href='../proc/printtimer.html'>PrintTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for a given timer.</p></td></tr>
			 
			   <tr><td><a href='../proc/pseudoinverse.html'>PseudoInverse</a></td><td><a href='../module/inversesolversmodule.html'>InverseSolversModule</a></td><td>Subroutine</td><td><p>Compute the pseudoinverse of a matrix.
 An implementation of the method of Hotelling \cite palser1998canonical.</p></td></tr>
			 
			   <tr><td><a href='../proc/purificationextrapolate.html'>PurificationExtrapolate</a></td><td><a href='../module/geometryoptimizationmodule.html'>GeometryOptimizationModule</a></td><td>Subroutine</td><td><p>Create a new guess at the Density Matrix after updating the geometry.
 Based on the purification algorithm in \cite niklasson2010trace .</p></td></tr>
			 
			   <tr><td><a href='../interface/redistributetripletlists.html'>RedistributeTripletLists</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/redistributetripletlists_c.html'>RedistributeTripletLists_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Redistribute some triplet lists amongst a set of processors.
 Takes in a list of triplet lists, one list for each processor. Then the
 all to all redistribution is performed along the given communicator.</p></td></tr>
			 
			   <tr><td><a href='../proc/redistributetripletlists_r.html'>RedistributeTripletLists_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Redistribute some triplet lists amongst a set of processors.
 Takes in a list of triplet lists, one list for each processor. Then the
 all to all redistribution is performed along the given communicator.</p></td></tr>
			 
			   <tr><td><a href='../interface/reduceandcomposematrixcleanup.html'>ReduceAndComposeMatrixCleanup</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/reduceandcomposematrixdata.html'>ReduceAndComposeMatrixData</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/reduceandcomposematrixsizes.html'>ReduceAndComposeMatrixSizes</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/reduceandsummatrixcleanup.html'>ReduceAndSumMatrixCleanup</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/reduceandsummatrixdata.html'>ReduceAndSumMatrixData</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/reduceandsummatrixsizes.html'>ReduceAndSumMatrixSizes</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/registertimer.html'>RegisterTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Register a timer with the timer module.  Call this before using that timer.</p></td></tr>
			 
			   <tr><td><a href='../proc/resizematrix.html'>ResizeMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Change the size of a matrix.
 If the new size is smaller, then values outside that range are deleted.
 IF the new size is bigger, zero padding is applied.
 Warning: this requires a full data redistribution.</p></td></tr>
			 
			   <tr><td><a href='../interface/resizetripletlist.html'>ResizeTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/resizetripletlist_c.html'>ResizeTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Increase the size of a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../proc/resizetripletlist_r.html'>ResizeTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Increase the size of a triplet list.</p></td></tr>
			 
			   <tr><td><a href='../interface/scalematrix.html'>ScaleMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/scalematrix~2.html'>ScaleMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/scalesquaretrigonometrytaylor.html'>ScaleSquareTrigonometryTaylor</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute trigonometric functions of a matrix using a taylor series.</p></td></tr>
			 
			   <tr><td><a href='../interface/setcoefficient.html'>SetCoefficient</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/setcoefficient~2.html'>SetCoefficient</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/setcoefficient~3.html'>SetCoefficient</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/setgenericerror.html'>SetGenericError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Routine to call if a generic error has occurred.</p></td></tr>
			 
			   <tr><td><a href='../proc/setmatrixprocessgrid.html'>SetMatrixProcessGrid</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>When you want to change the process grid of a matrix, you can call
 this routine with the new process grid value. Data will be automatically
 redistributed.</p></td></tr>
			 
			   <tr><td><a href='../proc/setparametersbeverbose.html'>SetParametersBeVerbose</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the verbosity.</p></td></tr>
			 
			   <tr><td><a href='../proc/setparametersconvergediff.html'>SetParametersConvergeDiff</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the convergence difference.</p></td></tr>
			 
			   <tr><td><a href='../proc/setparametersloadbalance.html'>SetParametersLoadBalance</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the load balance.</p></td></tr>
			 
			   <tr><td><a href='../proc/setparametersmaxiterations.html'>SetParametersMaxIterations</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the max iterations.</p></td></tr>
			 
			   <tr><td><a href='../proc/setparametersthreshold.html'>SetParametersThreshold</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the threshold.</p></td></tr>
			 
			   <tr><td><a href='../interface/setpoolsparsity.html'>SetPoolSparsity</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/settriplet.html'>SetTriplet</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/settripletat.html'>SetTripletAt</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/settripletat_c.html'>SetTripletAt_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Set the value of a triplet at a particular index.</p></td></tr>
			 
			   <tr><td><a href='../proc/settripletat_r.html'>SetTripletAt_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Set the value of a triplet at a particular index.</p></td></tr>
			 
			   <tr><td><a href='../interface/shifttripletlist.html'>ShiftTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/shifttripletlist_c.html'>ShiftTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Shift the rows and columns of a triplet list by set values.
 Frequently, we have a triplet list that comes from the global matrix which
 we would like to shift into a local matrix. In that case, just pass
 the negative of the starting row and column (plus 1) to this routine.</p></td></tr>
			 
			   <tr><td><a href='../proc/shifttripletlist_r.html'>ShiftTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Shift the rows and columns of a triplet list by set values.
 Frequently, we have a triplet list that comes from the global matrix which
 we would like to shift into a local matrix. In that case, just pass
 the negative of the starting row and column (plus 1) to this routine.</p></td></tr>
			 
			   <tr><td><a href='../proc/signfunction.html'>SignFunction</a></td><td><a href='../module/signsolversmodule.html'>SignSolversModule</a></td><td>Subroutine</td><td><p>Computes the matrix sign function.</p></td></tr>
			 
			   <tr><td><a href='../proc/sine.html'>Sine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the sine of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../interface/solverparameters_t.html'>SolverParameters_t</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/sortdensetripletlist.html'>SortDenseTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/sortdensetripletlist_c.html'>SortDenseTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Sort a triplet list assuming that the matrix it corresponds to is nearly
 dense.</p></td></tr>
			 
			   <tr><td><a href='../proc/sortdensetripletlist_r.html'>SortDenseTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Sort a triplet list assuming that the matrix it corresponds to is nearly
 dense.</p></td></tr>
			 
			   <tr><td><a href='../interface/sorttripletlist.html'>SortTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/sorttripletlist_c.html'>SortTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Sorts a triplet list by index values.
 Implementation is based on bucket sort. This is why it needs the number of
 matrix columns. Bubble sort is used within a bucket.</p></td></tr>
			 
			   <tr><td><a href='../proc/sorttripletlist_r.html'>SortTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Sorts a triplet list by index values.
 Implementation is based on bucket sort. This is why it needs the number of
 matrix columns. Bubble sort is used within a bucket.</p></td></tr>
			 
			   <tr><td><a href='../interface/splitmatrix.html'>SplitMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/splitmatrix~2.html'>SplitMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/splitmatrixcolumns.html'>SplitMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/splitmatrixtolocalblocks.html'>SplitMatrixToLocalBlocks</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/splitprocessgrid.html'>SplitProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Given a process grid, this splits it into two grids of even size</p></td></tr>
			 
			   <tr><td><a href='../proc/squareroot.html'>SquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Compute the square root of a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/starttimer.html'>StartTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Start the clock running for a given timer.</p></td></tr>
			 
			   <tr><td><a href='../proc/stoptimer.html'>StopTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Stop the clock for a given timer.</p></td></tr>
			 
			   <tr><td><a href='../interface/symmetrizetripletlist.html'>SymmetrizeTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/symmetrizetripletlist_c.html'>SymmetrizeTripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Symmetrizes an unsymmetric triplet list according to the specified
 symmetry type.</p></td></tr>
			 
			   <tr><td><a href='../proc/symmetrizetripletlist_r.html'>SymmetrizeTripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Subroutine</td><td><p>Symmetrizes an unsymmetric triplet list according to the specified
 symmetry type.</p></td></tr>
			 
			   <tr><td><a href='../proc/testreducedatarequest.html'>TestReduceDataRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the data of the matrices is complete.</p></td></tr>
			 
			   <tr><td><a href='../proc/testreduceinnerrequest.html'>TestReduceInnerRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the inner indices of the matrices is complete.</p></td></tr>
			 
			   <tr><td><a href='../proc/testreducesizerequest.html'>TestReduceSizeRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the size of the matrices is complete.</p></td></tr>
			 
			   <tr><td><a href='../interface/transposematrix.html'>TransposeMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/transposematrix~2.html'>TransposeMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/transposematrix~3.html'>TransposeMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/tripletlist_c.html'>TripletList_c</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/tripletlist_r.html'>TripletList_r</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/trs2.html'>TRS2</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the TRS2 method.
 Based on the TRS2 algorithm presented in \cite niklasson2002.</p></td></tr>
			 
			   <tr><td><a href='../proc/trs4.html'>TRS4</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the TRS4 method.
 Based on the TRS4 algorithm presented in \cite niklasson2002</p></td></tr>
			 
			   <tr><td><a href='../proc/undopermutematrix.html'>UndoPermuteMatrix</a></td><td><a href='../module/loadbalancermodule.html'>LoadBalancerModule</a></td><td>Subroutine</td><td><p>Undo a permutation applied to a matrix.</p></td></tr>
			 
			   <tr><td><a href='../proc/writecitation.html'>WriteCitation</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Write out a citation element.</p></td></tr>
			 
			   <tr><td><a href='../interface/writeelement.html'>WriteElement</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/writeheader.html'>WriteHeader</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Write out a header to the log.</p></td></tr>
			 
			   <tr><td><a href='../interface/writelistelement.html'>WriteListElement</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/writematrixtobinary.html'>WriteMatrixToBinary</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/writematrixtomatrixmarket.html'>WriteMatrixToMatrixMarket</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../interface/writemmline.html'>WriteMMLine</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Interface</td><td></td></tr>
			 
			   <tr><td><a href='../proc/writemmline_f.html'>WriteMMLine_f</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			 
			   <tr><td><a href='../proc/writemmline_ff.html'>WriteMMLine_ff</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			 
			   <tr><td><a href='../proc/writemmline_ii.html'>WriteMMLine_ii</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			 
			   <tr><td><a href='../proc/writemmline_iif.html'>WriteMMLine_iif</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			 
			   <tr><td><a href='../proc/writemmline_iiff.html'>WriteMMLine_iiff</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			 
			   <tr><td><a href='../proc/writemmsize.html'>WriteMMSize</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write the line describing the size of the matrix</p></td></tr>
			 
			 </tbody></table>
             
        </div>
      </div>

    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-4"><p>&copy; 2019 
                                          </p></div>
        <div class="col-xs-6 col-md-4 col-md-push-4">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/cmacmackin/ford">FORD</a>
            
          </p>
        </div>
        <div class="col-xs-12 col-md-4 col-md-pull-4"><p class="text-center"> NTPoly was developed by </p></div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>