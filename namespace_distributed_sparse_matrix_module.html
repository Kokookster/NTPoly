<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NTPoly: DistributedSparseMatrixModule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Types&nbsp;List</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Modules&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Module&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>DistributedSparseMatrixModule Module Reference</h1>
<p>A Module For Performing Distributed Sparse Matrix Operations.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">type &nbsp;</td><td class="memItemRight" valign="bottom"><b>DistributedSparseMatrix</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A datatype for a distributed blocked CSR matrix. <br/></td></tr>
<tr><td colspan="2"><h2>Functions/Subroutines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a567e622505b3b078234a09cf56936a51">ConstructEmpty</a> (this, matrix_dim_)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty sparse, distributed, matrix.  <a href="#a567e622505b3b078234a09cf56936a51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#aae95ae2e9f6a61874c7735c3c2544afb">DestructDistributedSparseMatrix</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destruct a distributed sparse matrix.  <a href="#aae95ae2e9f6a61874c7735c3c2544afb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a3e6003c0766c7d3cbd513ce6521e4733">CopyDistributedSparseMatrix</a> (matA, matB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a distributed sparse matrix in a safe way.  <a href="#a3e6003c0766c7d3cbd513ce6521e4733"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#aede98ef42882482ae77c6ecaf6f5be9f">ConstructFromMatrixMarket</a> (this, file_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct distributed sparse matrix from a matrix market file in parallel.  <a href="#aede98ef42882482ae77c6ecaf6f5be9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a86749ab4a78d2d8a7d86e2aebdff73a7">ConstructFromBinary</a> (this, file_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a distributed sparse matrix from a binary file in parallel.  <a href="#a86749ab4a78d2d8a7d86e2aebdff73a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a3e6353db4f745c3203ad7e59d68ea20f">WriteToBinary</a> (this, file_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a distributed sparse matrix to a file.  <a href="#a3e6353db4f745c3203ad7e59d68ea20f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a5d56f3081561a2030a77806fc72fa7a4">WriteToMatrixMarket</a> (this, file_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a distributed sparse matrix to a matrix market file.  <a href="#a5d56f3081561a2030a77806fc72fa7a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ada2eeef74742f9723014dd9c7c1bc428">FillFromTripletList</a> (this, triplet_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given.  <a href="#ada2eeef74742f9723014dd9c7c1bc428"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a31bae0704238eb5198d3820d691d534b">FillDistributedIdentity</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill in the values of a distributed matrix with the identity matrix.  <a href="#a31bae0704238eb5198d3820d691d534b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ac21e6655f13ec4ba399d4c01955a6056">FillDistributedPermutation</a> (this, permutation_vector, permuterows)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill in the values of a distributed matrix with a permutation. If you don't specify permuterows, will default to permuting rows.  <a href="#ac21e6655f13ec4ba399d4c01955a6056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ac004627c33bfb3e73f8787043f2182c7">GetTripletList</a> (this, triplet_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts a triplet list of the data that is stored on this process. Data is returned with absolute coordinates.  <a href="#ac004627c33bfb3e73f8787043f2182c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTEGER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#afcf0037a2838b6b3ef33a31a889502fa">GetActualDimension</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the actual dimension of the matrix.  <a href="#afcf0037a2838b6b3ef33a31a889502fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTEGER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a355a6d7146c95b6484a40fe87982448b">GetLogicalDimension</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the logical dimension of the matrix.  <a href="#a355a6d7146c95b6484a40fe87982448b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ad02266821165eeaca06c01b43f5f6666">IncrementDistributedSparseMatrix</a> (matA, matB, alpha_in, threshold_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine.  <a href="#ad02266821165eeaca06c01b43f5f6666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#af07dc4a45ae3c80485892af4e8bdc443">DotDistributedSparseMatrix</a> (matA, matB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">product = dot(Matrix A,Matrix B)  <a href="#af07dc4a45ae3c80485892af4e8bdc443"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ab4d76f620784dbb3954abb9ce381085c">DistributedGrandSum</a> (matA)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum up the elements in a matrix.  <a href="#ab4d76f620784dbb3954abb9ce381085c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a7610c2a547757afd0a5d451ec3135cf7">DistributedPairwiseMultiply</a> (matA, matB, matC)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Elementwise multiplication. C_ij = A_ij * B_ij.  <a href="#a7610c2a547757afd0a5d451ec3135cf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a6eacf86d6eba052ac88e8641b35d559a">DistributedGemm</a> (matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC.  <a href="#a6eacf86d6eba052ac88e8641b35d559a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a2f01707eec4871d24c017e66ab32cec7">ScaleDistributedSparseMatrix</a> (this, constant)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will scale a distributed sparse matrix by a constant.  <a href="#a2f01707eec4871d24c017e66ab32cec7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#ac9122c40f4e40fe503874b8ef62a71a3">DistributedSparseNorm</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm of a distributed sparse matrix along the rows.  <a href="#ac9122c40f4e40fe503874b8ef62a71a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a15a46b29b434c9a03888b4f919e676cc">Trace</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the trace of the matrix.  <a href="#a15a46b29b434c9a03888b4f919e676cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a492e39c9592268dc6f5a69f647a57f71">EigenCircle</a> (this, min_value, max_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem.  <a href="#a492e39c9592268dc6f5a69f647a57f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a127164f6b266403eedb14ead4cef2995">ComputeSigma</a> (this, sigma_value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute sigma for the inversion method.  <a href="#a127164f6b266403eedb14ead4cef2995"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#aec0daf1798b96010dec6d25801247480">PrintDistributedSparseMatrix</a> (this, file_name_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print ouf a distributed sparse matrix.  <a href="#aec0daf1798b96010dec6d25801247480"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a1255f164af2cb87e6095e64d513734b0">FilterSparseMatrix</a> (this, threshold)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A utility routine that filters a sparse matrix. All (absolute) values below the threshold are set to zero.  <a href="#a1255f164af2cb87e6095e64d513734b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTEGER(c_long)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a14f1f39ee0dbf388a3dbd3da9dfb56fd">GetSize</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the total number of non zero entries in the distributed sparse matrix.  <a href="#a14f1f39ee0dbf388a3dbd3da9dfb56fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_distributed_sparse_matrix_module.html#a2d3be41ff8f09ad1e1762d9591523ec3">GetLoadBalance</a> (this, min_size, max_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values.  <a href="#a2d3be41ff8f09ad1e1762d9591523ec3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A Module For Performing Distributed Sparse Matrix Operations. </p>
<hr/><h2>Function/Subroutine Documentation</h2>
<a class="anchor" id="a127164f6b266403eedb14ead4cef2995"></a><!-- doxytag: member="DistributedSparseMatrixModule::ComputeSigma" ref="a127164f6b266403eedb14ead4cef2995" args="(this, sigma_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::ComputeSigma </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(out)&nbsp;</td>
          <td class="paramname"> <em>sigma_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute sigma for the inversion method. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>describe this better. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to compute the sigma value of. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sigma_value</em>&nbsp;</td><td>sigma. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a567e622505b3b078234a09cf56936a51"></a><!-- doxytag: member="DistributedSparseMatrixModule::ConstructEmpty" ref="a567e622505b3b078234a09cf56936a51" args="(this, matrix_dim_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::ConstructEmpty </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>matrix_dim_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an empty sparse, distributed, matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to be constructed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matrix_dim_</em>&nbsp;</td><td>the dimension of the full matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86749ab4a78d2d8a7d86e2aebdff73a7"></a><!-- doxytag: member="DistributedSparseMatrixModule::ConstructFromBinary" ref="a86749ab4a78d2d8a7d86e2aebdff73a7" args="(this, file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::ConstructFromBinary </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in)&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a distributed sparse matrix from a binary file in parallel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the file being constructed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name</em>&nbsp;</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aede98ef42882482ae77c6ecaf6f5be9f"></a><!-- doxytag: member="DistributedSparseMatrixModule::ConstructFromMatrixMarket" ref="aede98ef42882482ae77c6ecaf6f5be9f" args="(this, file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::ConstructFromMatrixMarket </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in)&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct distributed sparse matrix from a matrix market file in parallel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the file being constructed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name</em>&nbsp;</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e6003c0766c7d3cbd513ce6521e4733"></a><!-- doxytag: member="DistributedSparseMatrixModule::CopyDistributedSparseMatrix" ref="a3e6003c0766c7d3cbd513ce6521e4733" args="(matA, matB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::CopyDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a distributed sparse matrix in a safe way. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>matrix to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>matB = matA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae95ae2e9f6a61874c7735c3c2544afb"></a><!-- doxytag: member="DistributedSparseMatrixModule::DestructDistributedSparseMatrix" ref="aae95ae2e9f6a61874c7735c3c2544afb" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::DestructDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destruct a distributed sparse matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to destruct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eacf86d6eba052ac88e8641b35d559a"></a><!-- doxytag: member="DistributedSparseMatrixModule::DistributedGemm" ref="a6eacf86d6eba052ac88e8641b35d559a" args="(matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::DistributedGemm </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>beta_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>threshold_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedMatrixMemoryPool_t),intent(inout),optional&nbsp;</td>
          <td class="paramname"> <em>memory_pool_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matC</em>&nbsp;</td><td>= alpha*matA*matB + beta*matC </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha_in</em>&nbsp;</td><td>scales the multiplication </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>beta_in</em>&nbsp;</td><td>scales matrix we sum on to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_in</em>&nbsp;</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>memory_pool_in a memory pool that can be used for the calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4d76f620784dbb3954abb9ce381085c"></a><!-- doxytag: member="DistributedSparseMatrixModule::DistributedGrandSum" ref="ab4d76f620784dbb3954abb9ce381085c" args="(matA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) DistributedSparseMatrixModule::DistributedGrandSum </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum up the elements in a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sum the sum of all elements. </dd></dl>

</div>
</div>
<a class="anchor" id="a7610c2a547757afd0a5d451ec3135cf7"></a><!-- doxytag: member="DistributedSparseMatrixModule::DistributedPairwiseMultiply" ref="a7610c2a547757afd0a5d451ec3135cf7" args="(matA, matB, matC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::DistributedPairwiseMultiply </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matC</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Elementwise multiplication. C_ij = A_ij * B_ij. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>matC</em>&nbsp;</td><td>= MatA mult MatB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9122c40f4e40fe503874b8ef62a71a3"></a><!-- doxytag: member="DistributedSparseMatrixModule::DistributedSparseNorm" ref="ac9122c40f4e40fe503874b8ef62a71a3" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) DistributedSparseMatrixModule::DistributedSparseNorm </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the norm of a distributed sparse matrix along the rows. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the norm value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="af07dc4a45ae3c80485892af4e8bdc443"></a><!-- doxytag: member="DistributedSparseMatrixModule::DotDistributedSparseMatrix" ref="af07dc4a45ae3c80485892af4e8bdc443" args="(matA, matB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) DistributedSparseMatrixModule::DotDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>product = dot(Matrix A,Matrix B) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>product the dot product. </dd></dl>

</div>
</div>
<a class="anchor" id="a492e39c9592268dc6f5a69f647a57f71"></a><!-- doxytag: member="DistributedSparseMatrixModule::EigenCircle" ref="a492e39c9592268dc6f5a69f647a57f71" args="(this, min_value, max_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::EigenCircle </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(out)&nbsp;</td>
          <td class="paramname"> <em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(out)&nbsp;</td>
          <td class="paramname"> <em>max_value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to compute the min/max of. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>min_value</em>&nbsp;</td><td>a lower bound on the eigenspectrum. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>max_value</em>&nbsp;</td><td>an uppder bound on the eigenspectrum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31bae0704238eb5198d3820d691d534b"></a><!-- doxytag: member="DistributedSparseMatrixModule::FillDistributedIdentity" ref="a31bae0704238eb5198d3820d691d534b" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::FillDistributedIdentity </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in the values of a distributed matrix with the identity matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this the matrix being filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac21e6655f13ec4ba399d4c01955a6056"></a><!-- doxytag: member="DistributedSparseMatrixModule::FillDistributedPermutation" ref="ac21e6655f13ec4ba399d4c01955a6056" args="(this, permutation_vector, permuterows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::FillDistributedPermutation </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,dimension(:),intent(in)&nbsp;</td>
          <td class="paramname"> <em>permutation_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LOGICAL,intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>permuterows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in the values of a distributed matrix with a permutation. If you don't specify permuterows, will default to permuting rows. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this the matrix being filled. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>permutation_vector</em>&nbsp;</td><td>describes for each row/column, where it goes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>permuterows</em>&nbsp;</td><td>if true permute rows, false permute columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada2eeef74742f9723014dd9c7c1bc428"></a><!-- doxytag: member="DistributedSparseMatrixModule::FillFromTripletList" ref="ada2eeef74742f9723014dd9c7c1bc428" args="(this, triplet_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::FillFromTripletList </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(TripletList_t)&nbsp;</td>
          <td class="paramname"> <em>triplet_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this the matrix to fill. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>triplet_list</em>&nbsp;</td><td>the triplet list of values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1255f164af2cb87e6095e64d513734b0"></a><!-- doxytag: member="DistributedSparseMatrixModule::FilterSparseMatrix" ref="a1255f164af2cb87e6095e64d513734b0" args="(this, threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::FilterSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in)&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A utility routine that filters a sparse matrix. All (absolute) values below the threshold are set to zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this matrix to filter </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>(absolute) values below this are filtered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcf0037a2838b6b3ef33a31a889502fa"></a><!-- doxytag: member="DistributedSparseMatrixModule::GetActualDimension" ref="afcf0037a2838b6b3ef33a31a889502fa" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER DistributedSparseMatrixModule::GetActualDimension </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the actual dimension of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dimension of the matrix; </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3be41ff8f09ad1e1762d9591523ec3"></a><!-- doxytag: member="DistributedSparseMatrixModule::GetLoadBalance" ref="a2d3be41ff8f09ad1e1762d9591523ec3" args="(this, min_size, max_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::GetLoadBalance </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(out)&nbsp;</td>
          <td class="paramname"> <em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(out)&nbsp;</td>
          <td class="paramname"> <em>max_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>The matrix to compute the measure on. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>min_size</em>&nbsp;</td><td>the minimum entries contained on a single process. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>max_size</em>&nbsp;</td><td>the maximum entries contained on a single process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a355a6d7146c95b6484a40fe87982448b"></a><!-- doxytag: member="DistributedSparseMatrixModule::GetLogicalDimension" ref="a355a6d7146c95b6484a40fe87982448b" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER DistributedSparseMatrixModule::GetLogicalDimension </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the logical dimension of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dimension of the matrix; </dd></dl>

</div>
</div>
<a class="anchor" id="a14f1f39ee0dbf388a3dbd3da9dfb56fd"></a><!-- doxytag: member="DistributedSparseMatrixModule::GetSize" ref="a14f1f39ee0dbf388a3dbd3da9dfb56fd" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER(c_long) DistributedSparseMatrixModule::GetSize </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total number of non zero entries in the distributed sparse matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the distributed sparse matrix to calculate the non-zero entries of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of non-zero entries in the matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="ac004627c33bfb3e73f8787043f2182c7"></a><!-- doxytag: member="DistributedSparseMatrixModule::GetTripletList" ref="ac004627c33bfb3e73f8787043f2182c7" args="(this, triplet_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::GetTripletList </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(TripletList_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>triplet_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts a triplet list of the data that is stored on this process. Data is returned with absolute coordinates. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the distributed sparse matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>triplet_list the list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad02266821165eeaca06c01b43f5f6666"></a><!-- doxytag: member="DistributedSparseMatrixModule::IncrementDistributedSparseMatrix" ref="ad02266821165eeaca06c01b43f5f6666" args="(matA, matB, alpha_in, threshold_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::IncrementDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>threshold_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha_in</em>&nbsp;</td><td>multiplier. Default value is 1.0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_in</em>&nbsp;</td><td>for flushing values to zero. Default value is 0.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec0daf1798b96010dec6d25801247480"></a><!-- doxytag: member="DistributedSparseMatrixModule::PrintDistributedSparseMatrix" ref="aec0daf1798b96010dec6d25801247480" args="(this, file_name_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::PrintDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>file_name_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print ouf a distributed sparse matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to print. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name_in</em>&nbsp;</td><td>optionally, you can pass a file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f01707eec4871d24c017e66ab32cec7"></a><!-- doxytag: member="DistributedSparseMatrixModule::ScaleDistributedSparseMatrix" ref="a2f01707eec4871d24c017e66ab32cec7" args="(this, constant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::ScaleDistributedSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in)&nbsp;</td>
          <td class="paramname"> <em>constant</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will scale a distributed sparse matrix by a constant. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this Matrix to scale. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constant</em>&nbsp;</td><td>scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15a46b29b434c9a03888b4f919e676cc"></a><!-- doxytag: member="DistributedSparseMatrixModule::Trace" ref="a15a46b29b434c9a03888b4f919e676cc" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) DistributedSparseMatrixModule::Trace </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the trace of the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the trace value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e6353db4f745c3203ad7e59d68ea20f"></a><!-- doxytag: member="DistributedSparseMatrixModule::WriteToBinary" ref="a3e6353db4f745c3203ad7e59d68ea20f" args="(this, file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::WriteToBinary </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in)&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a distributed sparse matrix to a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the Matrix to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name</em>&nbsp;</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d56f3081561a2030a77806fc72fa7a4"></a><!-- doxytag: member="DistributedSparseMatrixModule::WriteToMatrixMarket" ref="a5d56f3081561a2030a77806fc72fa7a4" args="(this, file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine DistributedSparseMatrixModule::WriteToMatrixMarket </td>
          <td>(</td>
          <td class="paramtype">TYPE(DistributedSparseMatrix)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in)&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a distributed sparse matrix to a matrix market file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the Matrix to write. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name</em>&nbsp;</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 26 Jul 2017 for NTPoly by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
