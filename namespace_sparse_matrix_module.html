<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NTPoly: SparseMatrixModule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Types&nbsp;List</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Modules&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Module&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SparseMatrixModule Module Reference</h1>
<p>A module for handling locally stored CSR matrices.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">type &nbsp;</td><td class="memItemRight" valign="bottom"><b>SparseMatrix_t</b></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A datatype for storing a CSR matrix. <br/></td></tr>
<tr><td colspan="2"><h2>Functions/Subroutines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a64a7c5c4620460e62d9cbd760a2ec4e6">ConstructEmptySparseMatrix</a> (this, columns, rows)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sparse matrix with a certain number of columns and rows. Will allocate storage for the outer values.  <a href="#a64a7c5c4620460e62d9cbd760a2ec4e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a90e47f280a103d4c504ff01b90605cae">ConstructSparseMatrixFromFile</a> (this, file_name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a sparse matrix by reading in a matrix market file.  <a href="#a90e47f280a103d4c504ff01b90605cae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#acbf01de74f78ba9d99d4c2fd45a51296">ConstructFromTripletList</a> (this, triplet_list, rows, columns)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a sparse matrix from a <b>SORTED</b> triplet list. The triplet list must be sorted to efficiently fill in the matrix. This constructor assumes <b>you</b> have already sorted the triplet list.  <a href="#acbf01de74f78ba9d99d4c2fd45a51296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a16a133c86a19385677ee9c7084e20bb1">DestructSparseMatrix</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Explicitly destruct a sparse matrix. This will always check if arrays are actually allocated, so you can feel free to destruct a matrix even if it has no data.  <a href="#a16a133c86a19385677ee9c7084e20bb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a686b451a1501bedb8eb83a473151e563">CopySparseMatrix</a> (matA, matB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a sparse matrix in a safe way.  <a href="#a686b451a1501bedb8eb83a473151e563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTEGER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a1bda85fa581624babf3f7de70a2b662a">GetRows</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of rows of a matrix.  <a href="#a1bda85fa581624babf3f7de70a2b662a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INTEGER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a78e09be9bc70d2bf41c58911731e1765">GetColumns</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of columns of a matrix.  <a href="#a78e09be9bc70d2bf41c58911731e1765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a87ed571372bc4847d2248708da180a01">ScaleSparseMatrix</a> (matA, constant)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Will scale a sparse matrix by a constant.  <a href="#a87ed571372bc4847d2248708da180a01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a89ae5fb3ef66cf080ff53ff28fcf565d">IncrementSparseMatrix</a> (matA, matB, alpha_in, threshold_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix B = alpha*Matrix A + Matrix B (AXPY). This will utilize the sparse vector addition routine.  <a href="#a89ae5fb3ef66cf080ff53ff28fcf565d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#adf732a824ab77d24e1549a5bb3d5a966">PairwiseMultiplySparseMatrix</a> (matA, matB, matC)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pairwise Multiply two matrices. This will utilize the sparse vector pairwise routine.  <a href="#adf732a824ab77d24e1549a5bb3d5a966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a83654ce7833fef7bd53e83a527e9d043">DotSparseMatrix</a> (matA, matB)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Product = sum(MatA[ij]*MatB[ij]).  <a href="#a83654ce7833fef7bd53e83a527e9d043"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a0c4f174f2f21c60867b97fb34ccec69e">Gemm</a> (matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply two matrices together, and add to the third. C := alpha*matA*op( matB ) + beta*matC This version is not really linear scaling, but it should be fast enough. Basically, we create a big buffer region of zeros so that we can accumulate in O(1) time. Then we scan over the buffer region and search for filled values. For small enough matrices this is fine, but it definitely isn't optimal.  <a href="#a0c4f174f2f21c60867b97fb34ccec69e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#ab9d88a7f1e5aa6434349da4bd812a255">SparseMatrixNorm</a> (this, norm_per_column)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the norm of a sparse matrix along the columns.  <a href="#ab9d88a7f1e5aa6434349da4bd812a255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">REAL(NTREAL)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#ad87f3d106779f70d701db4d86ae5e219">SparseMatrixGrandSum</a> (this)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum the elements of a matrix.  <a href="#ad87f3d106779f70d701db4d86ae5e219"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#aa199b79d29c158741ad9b04dd7d12143">TransposeSparseMatrix</a> (this, matT)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose a sparse matrix and return it in a separate matrix. The current implementation has you go from matrix to triplet list, triplet list to transposed triplet list. The triplet list must then be sorted and then the return matrix is constructed.  <a href="#aa199b79d29c158741ad9b04dd7d12143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a4af7dd4c94c261489f96af95385dea6a">ComposeSparseMatrixColumns</a> (mat_list, out_matrix)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of the first matrix are followed by the columns of the matrices in the list.  <a href="#a4af7dd4c94c261489f96af95385dea6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a9f02f81e1ade04f0d6560134eb1f8aa6">SplitSparseMatrixColumns</a> (this, num_blocks, split_list, block_offsets_out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take a matrix, and split into into small blocks.  <a href="#a9f02f81e1ade04f0d6560134eb1f8aa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a39b88112d8de6e9c2810c55d0547bdc0">MatrixToTripletList</a> (this, triplet_list)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a triplet list from a matrix.  <a href="#a39b88112d8de6e9c2810c55d0547bdc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">subroutine&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#a62fa4354df68071cc28240df33a9a2d7">PrintSparseMatrix</a> (this, file_name_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out a sparse matrix. We first create a triplet list, and then call the print triplet list function.  <a href="#a62fa4354df68071cc28240df33a9a2d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LOGICAL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sparse_matrix_module.html#aab4bab3cb03f6d40912cc2f35f609a42">CheckIfIdentity</a> (this, threshold_in)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if a matrix is equal to the identity matrix. This routine is really just for testing. You can multiply a matrix and its inverse, and then call this routine to make sure multiplication is correct.  <a href="#aab4bab3cb03f6d40912cc2f35f609a42"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A module for handling locally stored CSR matrices. </p>
<hr/><h2>Function/Subroutine Documentation</h2>
<a class="anchor" id="aab4bab3cb03f6d40912cc2f35f609a42"></a><!-- doxytag: member="SparseMatrixModule::CheckIfIdentity" ref="aab4bab3cb03f6d40912cc2f35f609a42" args="(this, threshold_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LOGICAL SparseMatrixModule::CheckIfIdentity </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>threshold_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a matrix is equal to the identity matrix. This routine is really just for testing. You can multiply a matrix and its inverse, and then call this routine to make sure multiplication is correct. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to check. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_in</em>&nbsp;</td><td>for flushing values to zero. Default value is 10^-8. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the matrix is equal to the identity matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a4af7dd4c94c261489f96af95385dea6a"></a><!-- doxytag: member="SparseMatrixModule::ComposeSparseMatrixColumns" ref="a4af7dd4c94c261489f96af95385dea6a" args="(mat_list, out_matrix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::ComposeSparseMatrixColumns </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),dimension(:),intent(in)&nbsp;</td>
          <td class="paramname"> <em>mat_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>out_matrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of the first matrix are followed by the columns of the matrices in the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mat_list</em>&nbsp;</td><td>list of matrices to compose. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>out_matrix</em>&nbsp;</td><td>= [Matrix 1 | Matrix 2, ...] . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64a7c5c4620460e62d9cbd760a2ec4e6"></a><!-- doxytag: member="SparseMatrixModule::ConstructEmptySparseMatrix" ref="a64a7c5c4620460e62d9cbd760a2ec4e6" args="(this, columns, rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::ConstructEmptySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(out)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>rows</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a sparse matrix with a certain number of columns and rows. Will allocate storage for the outer values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix being created. It will have the outer index allocated, but nothing else. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>columns</em>&nbsp;</td><td>number of matrix columns. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rows</em>&nbsp;</td><td>number of matrix rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbf01de74f78ba9d99d4c2fd45a51296"></a><!-- doxytag: member="SparseMatrixModule::ConstructFromTripletList" ref="acbf01de74f78ba9d99d4c2fd45a51296" args="(this, triplet_list, rows, columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::ConstructFromTripletList </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(out)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(TripletList_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>triplet_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>columns</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a sparse matrix from a <b>SORTED</b> triplet list. The triplet list must be sorted to efficiently fill in the matrix. This constructor assumes <b>you</b> have already sorted the triplet list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix being constructed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>triplet_list</em>&nbsp;</td><td>a list of triplet values. They must be sorted. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rows</em>&nbsp;</td><td>number of matrix rows </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>columns</em>&nbsp;</td><td>number of matrix columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90e47f280a103d4c504ff01b90605cae"></a><!-- doxytag: member="SparseMatrixModule::ConstructSparseMatrixFromFile" ref="a90e47f280a103d4c504ff01b90605cae" args="(this, file_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::ConstructSparseMatrixFromFile </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(out)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in)&nbsp;</td>
          <td class="paramname"> <em>file_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a sparse matrix by reading in a matrix market file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix being constructed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name</em>&nbsp;</td><td>name of the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a686b451a1501bedb8eb83a473151e563"></a><!-- doxytag: member="SparseMatrixModule::CopySparseMatrix" ref="a686b451a1501bedb8eb83a473151e563" args="(matA, matB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::CopySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sparse matrix in a safe way. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>matrix to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>matB = matA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16a133c86a19385677ee9c7084e20bb1"></a><!-- doxytag: member="SparseMatrixModule::DestructSparseMatrix" ref="a16a133c86a19385677ee9c7084e20bb1" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::DestructSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Explicitly destruct a sparse matrix. This will always check if arrays are actually allocated, so you can feel free to destruct a matrix even if it has no data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>this the matrix to free up </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83654ce7833fef7bd53e83a527e9d043"></a><!-- doxytag: member="SparseMatrixModule::DotSparseMatrix" ref="a83654ce7833fef7bd53e83a527e9d043" args="(matA, matB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) SparseMatrixModule::DotSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Product = sum(MatA[ij]*MatB[ij]). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>product </dd></dl>

</div>
</div>
<a class="anchor" id="a0c4f174f2f21c60867b97fb34ccec69e"></a><!-- doxytag: member="SparseMatrixModule::Gemm" ref="a0c4f174f2f21c60867b97fb34ccec69e" args="(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::Gemm </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LOGICAL,intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>IsATransposed_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LOGICAL,intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>IsBTransposed_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>beta_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>threshold_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(MatrixMemoryPool_t),intent(inout),optional,target&nbsp;</td>
          <td class="paramname"> <em>blocked_memory_pool_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply two matrices together, and add to the third. C := alpha*matA*op( matB ) + beta*matC This version is not really linear scaling, but it should be fast enough. Basically, we create a big buffer region of zeros so that we can accumulate in O(1) time. Then we scan over the buffer region and search for filled values. For small enough matrices this is fine, but it definitely isn't optimal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matC</em>&nbsp;</td><td>= alpha*matA*op( matB ) + beta*matC. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IsATransposed_in</em>&nbsp;</td><td>true if A is already transposed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IsBTransposed_in</em>&nbsp;</td><td>true if B is already transposed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha_in</em>&nbsp;</td><td>scales the multiplication. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>beta_in</em>&nbsp;</td><td>scales matrix we sum on to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_in</em>&nbsp;</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>blocked_memory_pool_in an optional memory pool for doing the calculation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>more performance tuning. </dd></dl>

</div>
</div>
<a class="anchor" id="a78e09be9bc70d2bf41c58911731e1765"></a><!-- doxytag: member="SparseMatrixModule::GetColumns" ref="a78e09be9bc70d2bf41c58911731e1765" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER SparseMatrixModule::GetColumns </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of columns of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of columns. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bda85fa581624babf3f7de70a2b662a"></a><!-- doxytag: member="SparseMatrixModule::GetRows" ref="a1bda85fa581624babf3f7de70a2b662a" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INTEGER SparseMatrixModule::GetRows </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of rows of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of rows. </dd></dl>

</div>
</div>
<a class="anchor" id="a89ae5fb3ef66cf080ff53ff28fcf565d"></a><!-- doxytag: member="SparseMatrixModule::IncrementSparseMatrix" ref="a89ae5fb3ef66cf080ff53ff28fcf565d" args="(matA, matB, alpha_in, threshold_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::IncrementSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>threshold_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix B = alpha*Matrix A + Matrix B (AXPY). This will utilize the sparse vector addition routine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alpha_in</em>&nbsp;</td><td>multiplier. Optional, default is 1.0 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold_in</em>&nbsp;</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>I don't like this hack where I have to check if MatrixB is allocated. </dd></dl>

</div>
</div>
<a class="anchor" id="a39b88112d8de6e9c2810c55d0547bdc0"></a><!-- doxytag: member="SparseMatrixModule::MatrixToTripletList" ref="a39b88112d8de6e9c2810c55d0547bdc0" args="(this, triplet_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::MatrixToTripletList </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(TripletList_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>triplet_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a triplet list from a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to construct the triplet list from. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>triplet_list</em>&nbsp;</td><td>the triplet list we created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf732a824ab77d24e1549a5bb3d5a966"></a><!-- doxytag: member="SparseMatrixModule::PairwiseMultiplySparseMatrix" ref="adf732a824ab77d24e1549a5bb3d5a966" args="(matA, matB, matC)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::PairwiseMultiplySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matC</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pairwise Multiply two matrices. This will utilize the sparse vector pairwise routine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matA</em>&nbsp;</td><td>Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>matB</em>&nbsp;</td><td>Matrix B. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>matC</em>&nbsp;</td><td>= MatA mult MatB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62fa4354df68071cc28240df33a9a2d7"></a><!-- doxytag: member="SparseMatrixModule::PrintSparseMatrix" ref="a62fa4354df68071cc28240df33a9a2d7" args="(this, file_name_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::PrintSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CHARACTER(len=*),intent(in),optional&nbsp;</td>
          <td class="paramname"> <em>file_name_in</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print out a sparse matrix. We first create a triplet list, and then call the print triplet list function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to be printed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>file_name_in</em>&nbsp;</td><td>optionally, you can pass a file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87ed571372bc4847d2248708da180a01"></a><!-- doxytag: member="SparseMatrixModule::ScaleSparseMatrix" ref="a87ed571372bc4847d2248708da180a01" args="(matA, constant)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::ScaleSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),intent(in)&nbsp;</td>
          <td class="paramname"> <em>constant</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Will scale a sparse matrix by a constant. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inout]</em>&nbsp;</td><td>matA Matrix A. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>constant</em>&nbsp;</td><td>scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad87f3d106779f70d701db4d86ae5e219"></a><!-- doxytag: member="SparseMatrixModule::SparseMatrixGrandSum" ref="ad87f3d106779f70d701db4d86ae5e219" args="(this)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REAL(NTREAL) SparseMatrixModule::SparseMatrixGrandSum </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum the elements of a matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>sum_value the sum of the matrix elements </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d88a7f1e5aa6434349da4bd812a255"></a><!-- doxytag: member="SparseMatrixModule::SparseMatrixNorm" ref="ab9d88a7f1e5aa6434349da4bd812a255" args="(this, norm_per_column)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::SparseMatrixNorm </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL(NTREAL),dimension(:),intent(out),allocatable&nbsp;</td>
          <td class="paramname"> <em>norm_per_column</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the norm of a sparse matrix along the columns. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to compute the norm of. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>norm_per_column</em>&nbsp;</td><td>the norm value for each column in this matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f02f81e1ade04f0d6560134eb1f8aa6"></a><!-- doxytag: member="SparseMatrixModule::SplitSparseMatrixColumns" ref="a9f02f81e1ade04f0d6560134eb1f8aa6" args="(this, num_blocks, split_list, block_offsets_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::SplitSparseMatrixColumns </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,intent(in)&nbsp;</td>
          <td class="paramname"> <em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),dimension(num_blocks),intent(out)&nbsp;</td>
          <td class="paramname"> <em>split_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER,dimension(num_blocks+1),intent(out),optional&nbsp;</td>
          <td class="paramname"> <em>block_offsets_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Take a matrix, and split into into small blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>matrix to perform this operation on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num_blocks</em>&nbsp;</td><td>number of blocks to split into. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>split_list</em>&nbsp;</td><td>1D array of blocks. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>block_offsets_out</em>&nbsp;</td><td>the offsets used for splitting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa199b79d29c158741ad9b04dd7d12143"></a><!-- doxytag: member="SparseMatrixModule::TransposeSparseMatrix" ref="aa199b79d29c158741ad9b04dd7d12143" args="(this, matT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine SparseMatrixModule::TransposeSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(in)&nbsp;</td>
          <td class="paramname"> <em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE(SparseMatrix_t),intent(inout)&nbsp;</td>
          <td class="paramname"> <em>matT</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose a sparse matrix and return it in a separate matrix. The current implementation has you go from matrix to triplet list, triplet list to transposed triplet list. The triplet list must then be sorted and then the return matrix is constructed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>this</em>&nbsp;</td><td>the matrix to be transposed. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>matT</em>&nbsp;</td><td>the input matrix transposed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 31 Jul 2017 for NTPoly by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
