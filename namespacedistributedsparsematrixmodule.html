<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTPoly: distributedsparsematrixmodule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NTPoly
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">distributedsparsematrixmodule Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A Module For Performing Distributed Sparse Matrix Operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A datatype for a distributed CSR matrix. A CSR matrix stores locally a block of SparseMatrix types. That local CSR matrix is also divided up into blocks for sending/receiving purposes. This allows us to deal with non square slices of a matrix, and is also important for the 3D multiply algorithm.  <a href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ab545767fa9a5b52b54dcbaa6d7040639"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#ab545767fa9a5b52b54dcbaa6d7040639">constructempty</a> (this, matrix_dim_)</td></tr>
<tr class="memdesc:ab545767fa9a5b52b54dcbaa6d7040639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty sparse, distributed, matrix.  <a href="#ab545767fa9a5b52b54dcbaa6d7040639">More...</a><br /></td></tr>
<tr class="separator:ab545767fa9a5b52b54dcbaa6d7040639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af5141e7589d12a182b401b963da6a5"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a3af5141e7589d12a182b401b963da6a5">destructdistributedsparsematrix</a> (this)</td></tr>
<tr class="memdesc:a3af5141e7589d12a182b401b963da6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a distributed sparse matrix.  <a href="#a3af5141e7589d12a182b401b963da6a5">More...</a><br /></td></tr>
<tr class="separator:a3af5141e7589d12a182b401b963da6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cc3e2ab870a4e19fc25fa478493d3c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a75cc3e2ab870a4e19fc25fa478493d3c">copydistributedsparsematrix</a> (matA, matB)</td></tr>
<tr class="memdesc:a75cc3e2ab870a4e19fc25fa478493d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a distributed sparse matrix in a safe way.  <a href="#a75cc3e2ab870a4e19fc25fa478493d3c">More...</a><br /></td></tr>
<tr class="separator:a75cc3e2ab870a4e19fc25fa478493d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe62c786b900828604b43dde3641916"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#acfe62c786b900828604b43dde3641916">fillfromtripletlist</a> (this, triplet_list)</td></tr>
<tr class="memdesc:acfe62c786b900828604b43dde3641916"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given.  <a href="#acfe62c786b900828604b43dde3641916">More...</a><br /></td></tr>
<tr class="separator:acfe62c786b900828604b43dde3641916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2713d8c3e1ec68f0d1181350debf7a63"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a2713d8c3e1ec68f0d1181350debf7a63">filldistributedidentity</a> (this)</td></tr>
<tr class="memdesc:a2713d8c3e1ec68f0d1181350debf7a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the values of a distributed matrix with the identity matrix.  <a href="#a2713d8c3e1ec68f0d1181350debf7a63">More...</a><br /></td></tr>
<tr class="separator:a2713d8c3e1ec68f0d1181350debf7a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971debe326be81bf9c2c2bf978bc1ac9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a971debe326be81bf9c2c2bf978bc1ac9">filldistributedpermutation</a> (this, permutation_vector, permuterows)</td></tr>
<tr class="memdesc:a971debe326be81bf9c2c2bf978bc1ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the values of a distributed matrix with the identity matrix. If you don't specify permuterows, will default to permuting rows.  <a href="#a971debe326be81bf9c2c2bf978bc1ac9">More...</a><br /></td></tr>
<tr class="separator:a971debe326be81bf9c2c2bf978bc1ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9813c682f64bf7570584ae064cca6db"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#ad9813c682f64bf7570584ae064cca6db">constructfrommatrixmarket</a> (this, file_name)</td></tr>
<tr class="memdesc:ad9813c682f64bf7570584ae064cca6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct distributed sparse matrix from a matrix market file in parallel.  <a href="#ad9813c682f64bf7570584ae064cca6db">More...</a><br /></td></tr>
<tr class="separator:ad9813c682f64bf7570584ae064cca6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3f9cdde1f8bae41400e5f55515ff52"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#aee3f9cdde1f8bae41400e5f55515ff52">constructfrombinary</a> (this, file_name)</td></tr>
<tr class="memdesc:aee3f9cdde1f8bae41400e5f55515ff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a distributed sparse matrix from a binary file in parallel.  <a href="#aee3f9cdde1f8bae41400e5f55515ff52">More...</a><br /></td></tr>
<tr class="separator:aee3f9cdde1f8bae41400e5f55515ff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45505c47edf885d45ad81d965dd07957"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a45505c47edf885d45ad81d965dd07957">writetobinary</a> (this, file_name)</td></tr>
<tr class="memdesc:a45505c47edf885d45ad81d965dd07957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a distributed sparse matrix to a file.  <a href="#a45505c47edf885d45ad81d965dd07957">More...</a><br /></td></tr>
<tr class="separator:a45505c47edf885d45ad81d965dd07957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e5b76c5742caae8aab816d06a609dd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a12e5b76c5742caae8aab816d06a609dd">writetomatrixmarket</a> (this, file_name)</td></tr>
<tr class="memdesc:a12e5b76c5742caae8aab816d06a609dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a distributed sparse matrix to a matrix market file.  <a href="#a12e5b76c5742caae8aab816d06a609dd">More...</a><br /></td></tr>
<tr class="separator:a12e5b76c5742caae8aab816d06a609dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601c4094f5f61a7b742041a0fb810e8a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a601c4094f5f61a7b742041a0fb810e8a">incrementdistributedsparsematrix</a> (matA, matB, alpha_in, threshold_in)</td></tr>
<tr class="memdesc:a601c4094f5f61a7b742041a0fb810e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine.  <a href="#a601c4094f5f61a7b742041a0fb810e8a">More...</a><br /></td></tr>
<tr class="separator:a601c4094f5f61a7b742041a0fb810e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c698c3eb4039b2cca4d37b97a4430f0"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a6c698c3eb4039b2cca4d37b97a4430f0">scaledistributedsparsematrix</a> (matA, constant)</td></tr>
<tr class="memdesc:a6c698c3eb4039b2cca4d37b97a4430f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will scale a distributed sparse matrix by a constant.  <a href="#a6c698c3eb4039b2cca4d37b97a4430f0">More...</a><br /></td></tr>
<tr class="separator:a6c698c3eb4039b2cca4d37b97a4430f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c3a40f3ef2ddb7c9f78ffacc5f7ff"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a963c3a40f3ef2ddb7c9f78ffacc5f7ff">distributedgemm</a> (matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in)</td></tr>
<tr class="memdesc:a963c3a40f3ef2ddb7c9f78ffacc5f7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC.  <a href="#a963c3a40f3ef2ddb7c9f78ffacc5f7ff">More...</a><br /></td></tr>
<tr class="separator:a963c3a40f3ef2ddb7c9f78ffacc5f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac88866a4f7acf53d7a2bed26918918"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#abac88866a4f7acf53d7a2bed26918918">distributedsparsenorm</a> (this)</td></tr>
<tr class="memdesc:abac88866a4f7acf53d7a2bed26918918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a distributed sparse matrix along the rows.  <a href="#abac88866a4f7acf53d7a2bed26918918">More...</a><br /></td></tr>
<tr class="separator:abac88866a4f7acf53d7a2bed26918918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa450bc8fc944fd81e0d554f225ad864a"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#aa450bc8fc944fd81e0d554f225ad864a">trace</a> (this)</td></tr>
<tr class="memdesc:aa450bc8fc944fd81e0d554f225ad864a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of the matrix.  <a href="#aa450bc8fc944fd81e0d554f225ad864a">More...</a><br /></td></tr>
<tr class="separator:aa450bc8fc944fd81e0d554f225ad864a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a510ac879816d92b96a2d65a2b2f28c"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a9a510ac879816d92b96a2d65a2b2f28c">eigencircle</a> (this, min_value, max_value)</td></tr>
<tr class="memdesc:a9a510ac879816d92b96a2d65a2b2f28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem.  <a href="#a9a510ac879816d92b96a2d65a2b2f28c">More...</a><br /></td></tr>
<tr class="separator:a9a510ac879816d92b96a2d65a2b2f28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3a86212bc069959f2366086036accd"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#ade3a86212bc069959f2366086036accd">printdistributedsparsematrix</a> (this, file_name_in)</td></tr>
<tr class="memdesc:ade3a86212bc069959f2366086036accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print ouf a distributed sparse matrix.  <a href="#ade3a86212bc069959f2366086036accd">More...</a><br /></td></tr>
<tr class="separator:ade3a86212bc069959f2366086036accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de55328992a548bfc9d5d40521d711"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a51de55328992a548bfc9d5d40521d711">computesigma</a> (this, sigma_value)</td></tr>
<tr class="memdesc:a51de55328992a548bfc9d5d40521d711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sigma for the inversion method.  <a href="#a51de55328992a548bfc9d5d40521d711">More...</a><br /></td></tr>
<tr class="separator:a51de55328992a548bfc9d5d40521d711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d993c24254247dd5dff151439ed21b"><td class="memItemLeft" align="right" valign="top">integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a10d993c24254247dd5dff151439ed21b">getsize</a> (this)</td></tr>
<tr class="memdesc:a10d993c24254247dd5dff151439ed21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of non zero entries in the distributed sparse matrix.  <a href="#a10d993c24254247dd5dff151439ed21b">More...</a><br /></td></tr>
<tr class="separator:a10d993c24254247dd5dff151439ed21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df56e0361173f090a62ae0c930ac6ff"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedsparsematrixmodule.html#a7df56e0361173f090a62ae0c930ac6ff">getloadbalance</a> (this, min_size, max_size)</td></tr>
<tr class="memdesc:a7df56e0361173f090a62ae0c930ac6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values.  <a href="#a7df56e0361173f090a62ae0c930ac6ff">More...</a><br /></td></tr>
<tr class="separator:a7df56e0361173f090a62ae0c930ac6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Module For Performing Distributed Sparse Matrix Operations. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a51de55328992a548bfc9d5d40521d711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51de55328992a548bfc9d5d40521d711">&#9670;&nbsp;</a></span>computesigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::computesigma </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>sigma_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sigma for the inversion method. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>describe this better. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the sigma value of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma_value</td><td>sigma. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab545767fa9a5b52b54dcbaa6d7040639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab545767fa9a5b52b54dcbaa6d7040639">&#9670;&nbsp;</a></span>constructempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::constructempty </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>matrix_dim_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty sparse, distributed, matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the matrix to be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_dim_</td><td>the dimension of the full matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee3f9cdde1f8bae41400e5f55515ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3f9cdde1f8bae41400e5f55515ff52">&#9670;&nbsp;</a></span>constructfrombinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::constructfrombinary </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a distributed sparse matrix from a binary file in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the file being constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9813c682f64bf7570584ae064cca6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9813c682f64bf7570584ae064cca6db">&#9670;&nbsp;</a></span>constructfrommatrixmarket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::constructfrommatrixmarket </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct distributed sparse matrix from a matrix market file in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the file being constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75cc3e2ab870a4e19fc25fa478493d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cc3e2ab870a4e19fc25fa478493d3c">&#9670;&nbsp;</a></span>copydistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::copydistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a distributed sparse matrix in a safe way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>matrix to copy </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>= matA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3af5141e7589d12a182b401b963da6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af5141e7589d12a182b401b963da6a5">&#9670;&nbsp;</a></span>destructdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::destructdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix to destruct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a963c3a40f3ef2ddb7c9f78ffacc5f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963c3a40f3ef2ddb7c9f78ffacc5f7ff">&#9670;&nbsp;</a></span>distributedgemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::distributedgemm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>beta_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(distributedmatrixmemorypool_t), intent(inout), optional&#160;</td>
          <td class="paramname"><em>memory_pool_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>scales the multiplication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta_in</td><td>scales matrix we sum on to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matC</td><td>= alpha*matA*matB + beta*matC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory_pool_in</td><td>a memory pool that can be used for the calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abac88866a4f7acf53d7a2bed26918918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac88866a4f7acf53d7a2bed26918918">&#9670;&nbsp;</a></span>distributedsparsenorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedsparsematrixmodule::distributedsparsenorm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a distributed sparse matrix along the rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the norm value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a id="a9a510ac879816d92b96a2d65a2b2f28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a510ac879816d92b96a2d65a2b2f28c">&#9670;&nbsp;</a></span>eigencircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::eigencircle </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the min/max of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_value</td><td>a lower bound on the eigenspectrum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_value</td><td>an uppder bound on the eigenspectrum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2713d8c3e1ec68f0d1181350debf7a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2713d8c3e1ec68f0d1181350debf7a63">&#9670;&nbsp;</a></span>filldistributedidentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedsparsematrixmodule::filldistributedidentity </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the values of a distributed matrix with the identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix being filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a971debe326be81bf9c2c2bf978bc1ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971debe326be81bf9c2c2bf978bc1ac9">&#9670;&nbsp;</a></span>filldistributedpermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedsparsematrixmodule::filldistributedpermutation </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>permutation_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>permuterows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the values of a distributed matrix with the identity matrix. If you don't specify permuterows, will default to permuting rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix being filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permutation_vector</td><td>describes for each row/column, where it goes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permuterows</td><td>if true permute rows, false permute columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfe62c786b900828604b43dde3641916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe62c786b900828604b43dde3641916">&#9670;&nbsp;</a></span>fillfromtripletlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::fillfromtripletlist </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(tripletlist_t), intent(in)&#160;</td>
          <td class="paramname"><em>triplet_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix to fill. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triplet_list</td><td>the triplet list of values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7df56e0361173f090a62ae0c930ac6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df56e0361173f090a62ae0c930ac6ff">&#9670;&nbsp;</a></span>getloadbalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::getloadbalance </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The matrix to compute the measure on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_size</td><td>the minimum entries contained on a single process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_size</td><td>the maximum entries contained on a single process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10d993c24254247dd5dff151439ed21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d993c24254247dd5dff151439ed21b">&#9670;&nbsp;</a></span>getsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function, public distributedsparsematrixmodule::getsize </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of non zero entries in the distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the distributed sparse matrix to calculate the non-zero entries of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of non-zero entries in the matrix. </dd></dl>

</div>
</div>
<a id="a601c4094f5f61a7b742041a0fb810e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601c4094f5f61a7b742041a0fb810e8a">&#9670;&nbsp;</a></span>incrementdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::incrementdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>Matrix B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>multiplier. Default value is 1.0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade3a86212bc069959f2366086036accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3a86212bc069959f2366086036accd">&#9670;&nbsp;</a></span>printdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::printdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>file_name_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print ouf a distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name_in</td><td>optionally, you can pass a file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c698c3eb4039b2cca4d37b97a4430f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c698c3eb4039b2cca4d37b97a4430f0">&#9670;&nbsp;</a></span>scaledistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedsparsematrixmodule::scaledistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in)&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will scale a distributed sparse matrix by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa450bc8fc944fd81e0d554f225ad864a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa450bc8fc944fd81e0d554f225ad864a">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedsparsematrixmodule::trace </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the trace of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trace value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a id="a45505c47edf885d45ad81d965dd07957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45505c47edf885d45ad81d965dd07957">&#9670;&nbsp;</a></span>writetobinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::writetobinary </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a distributed sparse matrix to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the Matrix to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12e5b76c5742caae8aab816d06a609dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e5b76c5742caae8aab816d06a609dd">&#9670;&nbsp;</a></span>writetomatrixmarket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedsparsematrixmodule::writetomatrixmarket </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a distributed sparse matrix to a matrix market file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the Matrix to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
