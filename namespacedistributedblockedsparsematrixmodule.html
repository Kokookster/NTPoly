<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTPoly: distributedblockedsparsematrixmodule Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NTPoly
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">distributedblockedsparsematrixmodule Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A Module For Performing Distributed Sparse Matrix Operations. Unlike in earlier versions, this one will be blocked. Each Process will hold many distributed sparse matrix blocks.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A datatype for a distributed blocked CSR matrix.  <a href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a8b17d8a13289dd3e437b80f85e1179c4"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a8b17d8a13289dd3e437b80f85e1179c4">constructempty</a> (this, matrix_dim_)</td></tr>
<tr class="memdesc:a8b17d8a13289dd3e437b80f85e1179c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty sparse, distributed, matrix.  <a href="#a8b17d8a13289dd3e437b80f85e1179c4">More...</a><br /></td></tr>
<tr class="separator:a8b17d8a13289dd3e437b80f85e1179c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a81828de1839b9e27e2fb9257f7c9"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a992a81828de1839b9e27e2fb9257f7c9">destructdistributedsparsematrix</a> (this)</td></tr>
<tr class="memdesc:a992a81828de1839b9e27e2fb9257f7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a distributed sparse matrix.  <a href="#a992a81828de1839b9e27e2fb9257f7c9">More...</a><br /></td></tr>
<tr class="separator:a992a81828de1839b9e27e2fb9257f7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02aee6c2548f8a84b663f384305cd74"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#ae02aee6c2548f8a84b663f384305cd74">copydistributedsparsematrix</a> (matA, matB)</td></tr>
<tr class="memdesc:ae02aee6c2548f8a84b663f384305cd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a distributed sparse matrix in a safe way.  <a href="#ae02aee6c2548f8a84b663f384305cd74">More...</a><br /></td></tr>
<tr class="separator:ae02aee6c2548f8a84b663f384305cd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d054c4dcaf9679ebbc9e24ac4d3d482"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a9d054c4dcaf9679ebbc9e24ac4d3d482">constructfrommatrixmarket</a> (this, file_name)</td></tr>
<tr class="memdesc:a9d054c4dcaf9679ebbc9e24ac4d3d482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct distributed sparse matrix from a matrix market file in parallel.  <a href="#a9d054c4dcaf9679ebbc9e24ac4d3d482">More...</a><br /></td></tr>
<tr class="separator:a9d054c4dcaf9679ebbc9e24ac4d3d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee7b25cd2371dc196154dbe61b07696"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a9ee7b25cd2371dc196154dbe61b07696">constructfrombinary</a> (this, file_name)</td></tr>
<tr class="memdesc:a9ee7b25cd2371dc196154dbe61b07696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a distributed sparse matrix from a binary file in parallel.  <a href="#a9ee7b25cd2371dc196154dbe61b07696">More...</a><br /></td></tr>
<tr class="separator:a9ee7b25cd2371dc196154dbe61b07696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6ffe3cc09f69fd1740a4cf97bcdd7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#ad5b6ffe3cc09f69fd1740a4cf97bcdd7">writetobinary</a> (this, file_name)</td></tr>
<tr class="memdesc:ad5b6ffe3cc09f69fd1740a4cf97bcdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a distributed sparse matrix to a file.  <a href="#ad5b6ffe3cc09f69fd1740a4cf97bcdd7">More...</a><br /></td></tr>
<tr class="separator:ad5b6ffe3cc09f69fd1740a4cf97bcdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b61e7638b15f3751decb36724bc537e"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a5b61e7638b15f3751decb36724bc537e">writetomatrixmarket</a> (this, file_name)</td></tr>
<tr class="memdesc:a5b61e7638b15f3751decb36724bc537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a distributed sparse matrix to a matrix market file.  <a href="#a5b61e7638b15f3751decb36724bc537e">More...</a><br /></td></tr>
<tr class="separator:a5b61e7638b15f3751decb36724bc537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf5a93f3f58acd9a9b8c703c131701d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#aeaf5a93f3f58acd9a9b8c703c131701d">fillfromtripletlist</a> (this, triplet_list)</td></tr>
<tr class="memdesc:aeaf5a93f3f58acd9a9b8c703c131701d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given.  <a href="#aeaf5a93f3f58acd9a9b8c703c131701d">More...</a><br /></td></tr>
<tr class="separator:aeaf5a93f3f58acd9a9b8c703c131701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec202250ab3200b16c6e674a6093f2"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a45ec202250ab3200b16c6e674a6093f2">filldistributedidentity</a> (this)</td></tr>
<tr class="memdesc:a45ec202250ab3200b16c6e674a6093f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the values of a distributed matrix with the identity matrix.  <a href="#a45ec202250ab3200b16c6e674a6093f2">More...</a><br /></td></tr>
<tr class="separator:a45ec202250ab3200b16c6e674a6093f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d40a91b066e5a19a19af836519a29f1"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a1d40a91b066e5a19a19af836519a29f1">filldistributedpermutation</a> (this, permutation_vector, permuterows)</td></tr>
<tr class="memdesc:a1d40a91b066e5a19a19af836519a29f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the values of a distributed matrix with a permutation. If you don't specify permuterows, will default to permuting rows.  <a href="#a1d40a91b066e5a19a19af836519a29f1">More...</a><br /></td></tr>
<tr class="separator:a1d40a91b066e5a19a19af836519a29f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf4c0d452de9521b097a3305bce618b"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#aeaf4c0d452de9521b097a3305bce618b">gettripletlist</a> (this, triplet_list)</td></tr>
<tr class="memdesc:aeaf4c0d452de9521b097a3305bce618b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a triplet list of the data that is stored on this process. Data is returned with absolute coordinates.  <a href="#aeaf4c0d452de9521b097a3305bce618b">More...</a><br /></td></tr>
<tr class="separator:aeaf4c0d452de9521b097a3305bce618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe1b4f710ecbdf07b3b1ef6cfaf4a6"><td class="memItemLeft" align="right" valign="top">pure integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a45fe1b4f710ecbdf07b3b1ef6cfaf4a6">getactualdimension</a> (this)</td></tr>
<tr class="memdesc:a45fe1b4f710ecbdf07b3b1ef6cfaf4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the actual dimension of the matrix.  <a href="#a45fe1b4f710ecbdf07b3b1ef6cfaf4a6">More...</a><br /></td></tr>
<tr class="separator:a45fe1b4f710ecbdf07b3b1ef6cfaf4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f62af1f0c9fa86fe05c1ba53ea8c36e"><td class="memItemLeft" align="right" valign="top">pure integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a3f62af1f0c9fa86fe05c1ba53ea8c36e">getlogicaldimension</a> (this)</td></tr>
<tr class="memdesc:a3f62af1f0c9fa86fe05c1ba53ea8c36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logical dimension of the matrix.  <a href="#a3f62af1f0c9fa86fe05c1ba53ea8c36e">More...</a><br /></td></tr>
<tr class="separator:a3f62af1f0c9fa86fe05c1ba53ea8c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002927cdf8241373f39e60d4b213ed5d"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a002927cdf8241373f39e60d4b213ed5d">incrementdistributedsparsematrix</a> (matA, matB, alpha_in, threshold_in)</td></tr>
<tr class="memdesc:a002927cdf8241373f39e60d4b213ed5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine.  <a href="#a002927cdf8241373f39e60d4b213ed5d">More...</a><br /></td></tr>
<tr class="separator:a002927cdf8241373f39e60d4b213ed5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ac50b4a1b08842edb0c23281b996b"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a729ac50b4a1b08842edb0c23281b996b">dotdistributedsparsematrix</a> (matA, matB)</td></tr>
<tr class="memdesc:a729ac50b4a1b08842edb0c23281b996b"><td class="mdescLeft">&#160;</td><td class="mdescRight">product = dot(Matrix A,Matrix B)  <a href="#a729ac50b4a1b08842edb0c23281b996b">More...</a><br /></td></tr>
<tr class="separator:a729ac50b4a1b08842edb0c23281b996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486ab0e0b375bbb585cea1fcab0dd6e9"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a486ab0e0b375bbb585cea1fcab0dd6e9">distributedgrandsum</a> (matA)</td></tr>
<tr class="memdesc:a486ab0e0b375bbb585cea1fcab0dd6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum up the elements in a matrix.  <a href="#a486ab0e0b375bbb585cea1fcab0dd6e9">More...</a><br /></td></tr>
<tr class="separator:a486ab0e0b375bbb585cea1fcab0dd6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada19ec30ff93b4daf69e2d056726edf1"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#ada19ec30ff93b4daf69e2d056726edf1">distributedpairwisemultiply</a> (matA, matB, matC)</td></tr>
<tr class="memdesc:ada19ec30ff93b4daf69e2d056726edf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiplication. C_ij = A_ij * B_ij.  <a href="#ada19ec30ff93b4daf69e2d056726edf1">More...</a><br /></td></tr>
<tr class="separator:ada19ec30ff93b4daf69e2d056726edf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187ef1a81828f482a04e01460b74d83a"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a187ef1a81828f482a04e01460b74d83a">distributedgemm</a> (matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in)</td></tr>
<tr class="memdesc:a187ef1a81828f482a04e01460b74d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC.  <a href="#a187ef1a81828f482a04e01460b74d83a">More...</a><br /></td></tr>
<tr class="separator:a187ef1a81828f482a04e01460b74d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae074dd88f55549f894f51c811f5ebeef"><td class="memItemLeft" align="right" valign="top">pure subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#ae074dd88f55549f894f51c811f5ebeef">scaledistributedsparsematrix</a> (this, constant)</td></tr>
<tr class="memdesc:ae074dd88f55549f894f51c811f5ebeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will scale a distributed sparse matrix by a constant.  <a href="#ae074dd88f55549f894f51c811f5ebeef">More...</a><br /></td></tr>
<tr class="separator:ae074dd88f55549f894f51c811f5ebeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62742ee149ff85b744204b5e23b521b3"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a62742ee149ff85b744204b5e23b521b3">distributedsparsenorm</a> (this)</td></tr>
<tr class="memdesc:a62742ee149ff85b744204b5e23b521b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the norm of a distributed sparse matrix along the rows.  <a href="#a62742ee149ff85b744204b5e23b521b3">More...</a><br /></td></tr>
<tr class="separator:a62742ee149ff85b744204b5e23b521b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8570a07aaa76e54c7d80cf221ceea"><td class="memItemLeft" align="right" valign="top">real(ntreal) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a05a8570a07aaa76e54c7d80cf221ceea">trace</a> (this)</td></tr>
<tr class="memdesc:a05a8570a07aaa76e54c7d80cf221ceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of the matrix.  <a href="#a05a8570a07aaa76e54c7d80cf221ceea">More...</a><br /></td></tr>
<tr class="separator:a05a8570a07aaa76e54c7d80cf221ceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bc0eb664b4bcaff4832494a39ad39b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a20bc0eb664b4bcaff4832494a39ad39b">eigencircle</a> (this, min_value, max_value)</td></tr>
<tr class="memdesc:a20bc0eb664b4bcaff4832494a39ad39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem.  <a href="#a20bc0eb664b4bcaff4832494a39ad39b">More...</a><br /></td></tr>
<tr class="separator:a20bc0eb664b4bcaff4832494a39ad39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e875f06bf92d1ffd51a7fee65b8c4"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#af31e875f06bf92d1ffd51a7fee65b8c4">computesigma</a> (this, sigma_value)</td></tr>
<tr class="memdesc:af31e875f06bf92d1ffd51a7fee65b8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sigma for the inversion method.  <a href="#af31e875f06bf92d1ffd51a7fee65b8c4">More...</a><br /></td></tr>
<tr class="separator:af31e875f06bf92d1ffd51a7fee65b8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17dea01f357e4e279901ffc34f6d972"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#af17dea01f357e4e279901ffc34f6d972">printdistributedsparsematrix</a> (this, file_name_in)</td></tr>
<tr class="memdesc:af17dea01f357e4e279901ffc34f6d972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print ouf a distributed sparse matrix.  <a href="#af17dea01f357e4e279901ffc34f6d972">More...</a><br /></td></tr>
<tr class="separator:af17dea01f357e4e279901ffc34f6d972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295e8a1edaea32a9b2f750abe395b348"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a295e8a1edaea32a9b2f750abe395b348">filtersparsematrix</a> (this, threshold)</td></tr>
<tr class="memdesc:a295e8a1edaea32a9b2f750abe395b348"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility routine that filters a sparse matrix. All (absolute) values below the threshold are set to zero.  <a href="#a295e8a1edaea32a9b2f750abe395b348">More...</a><br /></td></tr>
<tr class="separator:a295e8a1edaea32a9b2f750abe395b348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f4a2b2dee7cd3ba4a7d41deb7edd56"><td class="memItemLeft" align="right" valign="top">integer(c_long) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#ae4f4a2b2dee7cd3ba4a7d41deb7edd56">getsize</a> (this)</td></tr>
<tr class="memdesc:ae4f4a2b2dee7cd3ba4a7d41deb7edd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of non zero entries in the distributed sparse matrix.  <a href="#ae4f4a2b2dee7cd3ba4a7d41deb7edd56">More...</a><br /></td></tr>
<tr class="separator:ae4f4a2b2dee7cd3ba4a7d41deb7edd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391ffc7e14ba3826cf172972913f0044"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedistributedblockedsparsematrixmodule.html#a391ffc7e14ba3826cf172972913f0044">getloadbalance</a> (this, min_size, max_size)</td></tr>
<tr class="memdesc:a391ffc7e14ba3826cf172972913f0044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values.  <a href="#a391ffc7e14ba3826cf172972913f0044">More...</a><br /></td></tr>
<tr class="separator:a391ffc7e14ba3826cf172972913f0044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Module For Performing Distributed Sparse Matrix Operations. Unlike in earlier versions, this one will be blocked. Each Process will hold many distributed sparse matrix blocks. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="af31e875f06bf92d1ffd51a7fee65b8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31e875f06bf92d1ffd51a7fee65b8c4">&#9670;&nbsp;</a></span>computesigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::computesigma </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>sigma_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sigma for the inversion method. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>describe this better. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the sigma value of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma_value</td><td>sigma. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b17d8a13289dd3e437b80f85e1179c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b17d8a13289dd3e437b80f85e1179c4">&#9670;&nbsp;</a></span>constructempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::constructempty </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>matrix_dim_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty sparse, distributed, matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the matrix to be constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix_dim_</td><td>the dimension of the full matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ee7b25cd2371dc196154dbe61b07696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee7b25cd2371dc196154dbe61b07696">&#9670;&nbsp;</a></span>constructfrombinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::constructfrombinary </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a distributed sparse matrix from a binary file in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the file being constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d054c4dcaf9679ebbc9e24ac4d3d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d054c4dcaf9679ebbc9e24ac4d3d482">&#9670;&nbsp;</a></span>constructfrommatrixmarket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::constructfrommatrixmarket </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct distributed sparse matrix from a matrix market file in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>the file being constructed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae02aee6c2548f8a84b663f384305cd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02aee6c2548f8a84b663f384305cd74">&#9670;&nbsp;</a></span>copydistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::copydistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a distributed sparse matrix in a safe way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>matrix to copy </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>= matA </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a992a81828de1839b9e27e2fb9257f7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992a81828de1839b9e27e2fb9257f7c9">&#9670;&nbsp;</a></span>destructdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::destructdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix to destruct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187ef1a81828f482a04e01460b74d83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187ef1a81828f482a04e01460b74d83a">&#9670;&nbsp;</a></span>distributedgemm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::distributedgemm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>beta_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(distributedmatrixmemorypool_t), intent(inout), optional&#160;</td>
          <td class="paramname"><em>memory_pool_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two matrices together, and add to the third. C := alpha*matA*matB+ beta*matC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matC</td><td>= alpha*matA*matB + beta*matC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>scales the multiplication </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta_in</td><td>scales matrix we sum on to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">memory_pool_in</td><td>a memory pool that can be used for the calculation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486ab0e0b375bbb585cea1fcab0dd6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486ab0e0b375bbb585cea1fcab0dd6e9">&#9670;&nbsp;</a></span>distributedgrandsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedblockedsparsematrixmodule::distributedgrandsum </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum up the elements in a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum the sum of all elements. </dd></dl>

</div>
</div>
<a id="ada19ec30ff93b4daf69e2d056726edf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada19ec30ff93b4daf69e2d056726edf1">&#9670;&nbsp;</a></span>distributedpairwisemultiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::distributedpairwisemultiply </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise multiplication. C_ij = A_ij * B_ij. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matC</td><td>= MatA mult MatB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62742ee149ff85b744204b5e23b521b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62742ee149ff85b744204b5e23b521b3">&#9670;&nbsp;</a></span>distributedsparsenorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedblockedsparsematrixmodule::distributedsparsenorm </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the norm of a distributed sparse matrix along the rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the norm value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a id="a729ac50b4a1b08842edb0c23281b996b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729ac50b4a1b08842edb0c23281b996b">&#9670;&nbsp;</a></span>dotdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedblockedsparsematrixmodule::dotdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>product = dot(Matrix A,Matrix B) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>product the dot product. </dd></dl>

</div>
</div>
<a id="a20bc0eb664b4bcaff4832494a39ad39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bc0eb664b4bcaff4832494a39ad39b">&#9670;&nbsp;</a></span>eigencircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::eigencircle </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(out)&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a bounds on the minimum and maximum eigenvalue of a matrix. Uses Gershgorin's theorem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the min/max of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_value</td><td>a lower bound on the eigenspectrum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_value</td><td>an uppder bound on the eigenspectrum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ec202250ab3200b16c6e674a6093f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ec202250ab3200b16c6e674a6093f2">&#9670;&nbsp;</a></span>filldistributedidentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::filldistributedidentity </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the values of a distributed matrix with the identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix being filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d40a91b066e5a19a19af836519a29f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d40a91b066e5a19a19af836519a29f1">&#9670;&nbsp;</a></span>filldistributedpermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::filldistributedpermutation </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>permutation_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>permuterows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the values of a distributed matrix with a permutation. If you don't specify permuterows, will default to permuting rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix being filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permutation_vector</td><td>describes for each row/column, where it goes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permuterows</td><td>if true permute rows, false permute columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeaf5a93f3f58acd9a9b8c703c131701d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf5a93f3f58acd9a9b8c703c131701d">&#9670;&nbsp;</a></span>fillfromtripletlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::fillfromtripletlist </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(tripletlist_t)&#160;</td>
          <td class="paramname"><em>triplet_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine fills in a matrix based on local triplet lists. Each process should pass in triplet lists with global coordinates. It doesn't matter where each triplet is stored, as long as global coordinates are given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>the matrix to fill. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triplet_list</td><td>the triplet list of values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a295e8a1edaea32a9b2f750abe395b348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295e8a1edaea32a9b2f750abe395b348">&#9670;&nbsp;</a></span>filtersparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::filtersparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in)&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility routine that filters a sparse matrix. All (absolute) values below the threshold are set to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>matrix to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>(absolute) values below this are filtered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45fe1b4f710ecbdf07b3b1ef6cfaf4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45fe1b4f710ecbdf07b3b1ef6cfaf4a6">&#9670;&nbsp;</a></span>getactualdimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function, public distributedblockedsparsematrixmodule::getactualdimension </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the actual dimension of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dimension of the matrix; </dd></dl>

</div>
</div>
<a id="a391ffc7e14ba3826cf172972913f0044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391ffc7e14ba3826cf172972913f0044">&#9670;&nbsp;</a></span>getloadbalance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::getloadbalance </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>min_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(out)&#160;</td>
          <td class="paramname"><em>max_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a measure of how load balanced this matrix is. For each process, the number of non-zero entries is calculated. Then, this function returns the max and min of those values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The matrix to compute the measure on. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_size</td><td>the minimum entries contained on a single process. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_size</td><td>the maximum entries contained on a single process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f62af1f0c9fa86fe05c1ba53ea8c36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f62af1f0c9fa86fe05c1ba53ea8c36e">&#9670;&nbsp;</a></span>getlogicaldimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure integer function, public distributedblockedsparsematrixmodule::getlogicaldimension </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the logical dimension of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dimension of the matrix; </dd></dl>

</div>
</div>
<a id="ae4f4a2b2dee7cd3ba4a7d41deb7edd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f4a2b2dee7cd3ba4a7d41deb7edd56">&#9670;&nbsp;</a></span>getsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(c_long) function, public distributedblockedsparsematrixmodule::getsize </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of non zero entries in the distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the distributed sparse matrix to calculate the non-zero entries of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of non-zero entries in the matrix. </dd></dl>

</div>
</div>
<a id="aeaf4c0d452de9521b097a3305bce618b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf4c0d452de9521b097a3305bce618b">&#9670;&nbsp;</a></span>gettripletlist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::gettripletlist </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(tripletlist_t), intent(inout)&#160;</td>
          <td class="paramname"><em>triplet_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a triplet list of the data that is stored on this process. Data is returned with absolute coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the distributed sparse matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triplet_list</td><td>the list to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a002927cdf8241373f39e60d4b213ed5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002927cdf8241373f39e60d4b213ed5d">&#9670;&nbsp;</a></span>incrementdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::incrementdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>matA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>matB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>alpha_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix B = alpha*Matrix A + Matrix B (AXPY) This will utilize the sparse vector increment routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matA</td><td>Matrix A. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">matB</td><td>Matrix B. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha_in</td><td>multiplier. Default value is 1.0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold_in</td><td>for flushing values to zero. Default value is 0.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af17dea01f357e4e279901ffc34f6d972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17dea01f357e4e279901ffc34f6d972">&#9670;&nbsp;</a></span>printdistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::printdistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in), optional&#160;</td>
          <td class="paramname"><em>file_name_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print ouf a distributed sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to print. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name_in</td><td>optionally, you can pass a file to print to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae074dd88f55549f894f51c811f5ebeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae074dd88f55549f894f51c811f5ebeef">&#9670;&nbsp;</a></span>scaledistributedsparsematrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine, public distributedblockedsparsematrixmodule::scaledistributedsparsematrix </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real(ntreal), intent(in)&#160;</td>
          <td class="paramname"><em>constant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will scale a distributed sparse matrix by a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>Matrix to scale. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant</td><td>scale factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a8570a07aaa76e54c7d80cf221ceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8570a07aaa76e54c7d80cf221ceea">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real(ntreal) function, public distributedblockedsparsematrixmodule::trace </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the trace of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the matrix to compute the norm of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trace value of the full distributed sparse matrix. </dd></dl>

</div>
</div>
<a id="ad5b6ffe3cc09f69fd1740a4cf97bcdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b6ffe3cc09f69fd1740a4cf97bcdd7">&#9670;&nbsp;</a></span>writetobinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::writetobinary </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a distributed sparse matrix to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the Matrix to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b61e7638b15f3751decb36724bc537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b61e7638b15f3751decb36724bc537e">&#9670;&nbsp;</a></span>writetomatrixmarket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public distributedblockedsparsematrixmodule::writetomatrixmarket </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structdistributedblockedsparsematrixmodule_1_1distributedsparsematrix.html">distributedsparsematrix</a>)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len=*), intent(in)&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a distributed sparse matrix to a matrix market file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>the Matrix to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>name of the file to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
